function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

function useMutation(query) {
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: !1,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions,
        operation: result.operation
      });
    }
    return result;
  }
  function _ref2() {
    isMounted.current = !1;
  }
  var isMounted = useRef(!0), client = useClient(), ref = useState(initialState), state = ref[0], setState = ref[1], executeMutation = useCallback((function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: !0
    }));
    return toPromise(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);
  }), [ client, query, setState ]);
  useEffect((function() {
    return _ref2;
  }), []);
  return [ state, executeMutation ];
}

function _ref3() {
  return currentInit;
}

function useSource(input, transform) {
  function _ref() {
    return input;
  }
  function _ref5(value) {
    if (!currentInit) {
      setState((function _ref4(prevValue) {
        return isShallowDifferent(prevValue, value) ? value : prevValue;
      }));
    }
  }
  var ref = useMemo((function() {
    var subject = makeSubject(), source = concat([ map(_ref)(fromValue(input)), subject.source ]), updateInput = function(nextInput) {
      var prevInput = input;
      try {
        if (nextInput !== prevInput) {
          subject.next(input = nextInput);
        }
      } catch (error) {
        input = prevInput;
        throw error;
      }
    };
    return [ source, updateInput ];
  }), []), input$ = ref[0], updateInput = ref[1], ref$1 = useState((function() {
    currentInit = !0;
    var state;
    try {
      subscribe((function _ref2(value) {
        state = value;
      }))(takeWhile(_ref3)(transform(input$))).unsubscribe();
    } finally {
      currentInit = !1;
    }
    return state;
  })), state = ref$1[0], setState = ref$1[1];
  useEffect((function() {
    return subscribe(_ref5)(transform(input$, state)).unsubscribe;
  }), [ input$ ]);
  return [ state, updateInput ];
}

function useRequest(query, variables) {
  var prev = useRef(void 0);
  return useMemo((function() {
    var request = createRequest(query, variables);
    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }), [ query, variables ]);
}

function _ref3$1(x) {
  return void 0 !== x;
}

function _ref4(result, partial) {
  return _extends({}, result, partial);
}

function _ref5(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !1,
    stale: !!stale,
    data: data,
    error: error,
    operation: operation,
    extensions: extensions
  };
}

function _ref6(query$) {
  if (!query$) {
    return fromValue({
      fetching: !1,
      stale: !1
    });
  }
  return concat([ fromValue({
    fetching: !0,
    stale: !1
  }), map(_ref5)(query$), fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function _ref7(query$$, prevState) {
  return scan(_ref4, prevState || initialState)(switchMap(_ref6)(query$$));
}

function useQuery(args) {
  var client = useClient(), request = useRequest(args.query, args.variables), makeQuery$ = useCallback((function(opts) {
    var suspense = isSuspense(client, args.context), source = suspense ? sources.get(request.key) : void 0;
    if (!source) {
      source = client.executeQuery(request, _extends({}, {
        requestPolicy: args.requestPolicy,
        pollInterval: args.pollInterval
      }, args.context, opts));
      if (suspense) {
        source = function toSuspenseSource(source) {
          function _ref(result) {
            if (resolve && void 0 === cache) {
              resolve(result);
            }
            cache = result;
          }
          function _ref2(_resolve) {
            resolve = _resolve;
          }
          var cache, resolve, shared = share(source), suspend$ = function(sink) {
            onPush(_ref)(shared)(sink);
            if (void 0 === cache) {
              throw new Promise(_ref2);
            }
          };
          return concat([ filter(_ref3$1)(map((function() {
            return cache;
          }))(fromValue(cache))), suspend$ ]);
        }(source);
        if ("undefined" != typeof window) {
          sources.set(request.key, source);
        }
      }
    }
    return source;
  }), [ client, request, args.requestPolicy, args.pollInterval, args.context ]), query$ = useMemo((function() {
    return args.pause ? null : makeQuery$();
  }), [ args.pause, makeQuery$ ]), ref = useSource(query$, useCallback(_ref7, [])), state = ref[0], update = ref[1], executeQuery = useCallback((function(opts) {
    update(makeQuery$(_extends({}, {
      suspense: !1
    }, opts)));
  }), [ update, makeQuery$ ]);
  useEffect((function() {
    sources.delete(request.key);
    if (!isSuspense(client, args.context)) {
      update(query$);
    }
  }), [ update, client, query$, request, args.context ]);
  if (isSuspense(client, args.context)) {
    update(query$);
  }
  return [ state, executeQuery ];
}

function _ref2(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !0,
    stale: !!stale,
    data: data,
    error: error,
    extensions: extensions,
    operation: operation
  };
}

function _ref3$2(subscription$) {
  if (!subscription$) {
    return fromValue({
      fetching: !1
    });
  }
  return concat([ fromValue({
    fetching: !0,
    stale: !1
  }), map(_ref2)(subscription$), fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function useSubscription(args, handler) {
  function _ref(result, partial) {
    var handler = handlerRef.current, data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
    return _extends({}, result, partial, {
      data: data
    });
  }
  var request, makeSubscription$, subscription$, ref, state, update, executeSubscription, client = useClient(), handlerRef = useRef(handler);
  handlerRef.current = handler;
  request = useRequest(args.query, args.variables);
  makeSubscription$ = useCallback((function(opts) {
    return client.executeSubscription(request, _extends({}, args.context, opts));
  }), [ client, request, args.context ]);
  state = (ref = useSource(subscription$ = useMemo((function() {
    return args.pause ? null : makeSubscription$();
  }), [ args.pause, makeSubscription$ ]), useCallback((function(subscription$$, prevState) {
    return scan(_ref, prevState || initialState)(switchMap(_ref3$2)(subscription$$));
  }), [])))[0];
  executeSubscription = useCallback((function(opts) {
    return update(makeSubscription$(opts));
  }), [ update = ref[1], makeSubscription$ ]);
  useEffect((function() {
    update(subscription$);
  }), [ update, subscription$ ]);
  return [ state, executeSubscription ];
}

function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children(_extends({}, mutation[0], {
    executeMutation: mutation[1]
  }));
}

function Query(props) {
  var query = useQuery(props);
  return props.children(_extends({}, query[0], {
    executeQuery: query[1]
  }));
}

function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children(_extends({}, subscription[0], {
    executeSubscription: subscription[1]
  }));
}

var defaultClient, Context, Provider, Consumer, hasWarnedAboutDefault, useClient, initialState, currentInit, isShallowDifferent, isSuspense, sources;

import { createClient, createRequest } from "@urql/core";

export * from "@urql/core";

import { createContext, useContext, useRef, useState, useCallback, useEffect, useMemo } from "react";

import { toPromise, makeSubject, concat, map, fromValue, subscribe, takeWhile, filter, share, onPush, scan, switchMap } from "wonka";

defaultClient = createClient({
  url: "/graphql"
});

Provider = (Context = createContext(defaultClient)).Provider;

Consumer = Context.Consumer;

hasWarnedAboutDefault = !1;

useClient = function() {
  var client = useContext(Context);
  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
};

initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
};

currentInit = !1;

isShallowDifferent = function(a, b) {
  var x, x$1;
  if ("object" != typeof a || "object" != typeof b) {
    return a !== b;
  }
  for (x in a) {
    if (!(x in b)) {
      return !0;
    }
  }
  for (x$1 in b) {
    if (a[x$1] !== b[x$1]) {
      return !0;
    }
  }
  return !1;
};

isSuspense = function(client, context) {
  return client.suspense && (!context || !1 !== context.suspense);
};

sources = new Map;

export { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };
//# sourceMappingURL=urql.es.js.map
