{"version":3,"file":"urql.min.es.js","sources":["../src/context.ts","../src/hooks/constants.ts","../src/hooks/useMutation.ts","../src/hooks/useSource.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect, useState } from 'react';\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  takeWhile,\n  pipe,\n  map,\n  concat,\n  subscribe,\n} from 'wonka';\n\ntype Updater<T> = (input: T) => void;\n\nlet currentInit = false;\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\nexport function useSource<T, R>(\n  input: T,\n  transform: (input$: Source<T>, initial?: R) => Source<R>\n): [R, Updater<T>] {\n  const [input$, updateInput] = useMemo((): [Source<T>, (value: T) => void] => {\n    const subject = makeSubject<T>();\n    const source = concat([\n      pipe(\n        fromValue(input),\n        map(() => input)\n      ),\n      subject.source,\n    ]);\n\n    const updateInput = (nextInput: T) => {\n      const prevInput = input;\n      try {\n        if (nextInput !== prevInput) subject.next((input = nextInput));\n      } catch (error) {\n        // If we suspend then React will preserve the component's state\n        // which means we'll need to prepare that the next update must be\n        // able to retrigger an update of the input.\n        input = prevInput;\n        throw error;\n      }\n    };\n\n    return [source, updateInput];\n  }, []);\n\n  const [state, setState] = useState<R>(() => {\n    currentInit = true;\n    let state: R;\n    try {\n      pipe(\n        transform(input$),\n        takeWhile(() => currentInit),\n        subscribe(value => {\n          state = value;\n        })\n      ).unsubscribe();\n    } finally {\n      currentInit = false;\n    }\n\n    return state!;\n  });\n\n  useEffect(() => {\n    return pipe(\n      transform(input$, state),\n      subscribe(value => {\n        if (!currentInit) {\n          setState(prevValue => {\n            return isShallowDifferent(prevValue, value) ? value : prevValue;\n          });\n        }\n      })\n    ).unsubscribe;\n  }, [input$ /* `state` is only an initialiser */]);\n\n  return [state, updateInput];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  Source,\n  pipe,\n  share,\n  concat,\n  onPush,\n  fromValue,\n  switchMap,\n  filter,\n  map,\n  scan,\n} from 'wonka';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\n/** Convert the Source to a React Suspense source on demand */\nfunction toSuspenseSource<T>(source: Source<T>): Source<T> {\n  const shared = share(source);\n  let cache: T | undefined;\n  let resolve: (value: T) => void;\n\n  const suspend$: Source<T> = sink => {\n    pipe(\n      shared,\n      onPush(result => {\n        // The first result that is received will resolve the Suspense promise\n        if (resolve && cache === undefined) resolve(result);\n        cache = result;\n      })\n    )(sink);\n\n    // If we haven't got a previous result then throw a Suspense promise\n    if (cache === undefined) {\n      throw new Promise<T>(_resolve => {\n        resolve = _resolve;\n      });\n    }\n  };\n\n  return concat([\n    pipe(\n      fromValue<T>(cache!),\n      map<T, T>(() => cache!),\n      filter(x => x !== undefined)\n    ),\n    suspend$,\n  ]);\n}\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nconst sources = new Map<number, Source<OperationResult>>();\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      // Determine whether suspense is enabled for the given operation\n      const suspense = isSuspense(client, args.context);\n      let source: Source<OperationResult> | void = suspense\n        ? sources.get(request.key)\n        : undefined;\n\n      if (!source) {\n        source = client.executeQuery(request, {\n          requestPolicy: args.requestPolicy,\n          pollInterval: args.pollInterval,\n          ...args.context,\n          ...opts,\n        });\n\n        // Create a suspense source and cache it for the given request\n        if (suspense) {\n          source = toSuspenseSource(source);\n          if (typeof window !== 'undefined') {\n            sources.set(request.key, source);\n          }\n        }\n      }\n\n      return source;\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const query$ = useMemo(() => {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]);\n\n  const [state, update] = useSource(\n    query$,\n    useCallback((query$$, prevState?: UseQueryState<Data, Variables>) => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result: UseQueryState<Data, Variables>, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          prevState || initialState\n        )\n      );\n    }, [])\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      update(makeQuery$({ suspense: false, ...opts }));\n    },\n    [update, makeQuery$]\n  );\n\n  useEffect(() => {\n    sources.delete(request.key); // Delete any cached suspense source\n    if (!isSuspense(client, args.context)) update(query$);\n  }, [update, client, query$, request, args.context]);\n\n  if (isSuspense(client, args.context)) update(query$);\n\n  return [state, executeQuery];\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler!;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription<Data, Variables>(request, {\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.context]\n  );\n\n  const subscription$ = useMemo(() => {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]);\n\n  const [state, update] = useSource(\n    subscription$,\n    useCallback(\n      (subscription$$, prevState?: UseSubscriptionState<Result, Variables>) => {\n        return pipe(\n          subscription$$,\n          switchMap(subscription$ => {\n            if (!subscription$) return fromValue({ fetching: false });\n\n            return concat([\n              // Initially set fetching to true\n              fromValue({ fetching: true, stale: false }),\n              pipe(\n                subscription$,\n                map(({ stale, data, error, extensions, operation }) => ({\n                  fetching: true,\n                  stale: !!stale,\n                  data,\n                  error,\n                  extensions,\n                  operation,\n                }))\n              ),\n              // When the source proactively closes, fetching is set to false\n              fromValue({ fetching: false, stale: false }),\n            ]);\n          }),\n          // The individual partial results are merged into each previous result\n          scan(\n            (result: UseSubscriptionState<Result, Variables>, partial: any) => {\n              const { current: handler } = handlerRef;\n              // If a handler has been passed, it's used to merge new data in\n              const data =\n                partial.data !== undefined\n                  ? typeof handler === 'function'\n                    ? handler(result.data, partial.data)\n                    : partial.data\n                  : result.data;\n              return { ...result, ...partial, data };\n            },\n            prevState || initialState\n          )\n        );\n      },\n      []\n    )\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  useEffect(() => {\n    update(subscription$);\n  }, [update, subscription$]);\n\n  return [state, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],"names":["Context","hasWarnedAboutDefault","fetching","stale","undefined","error","data","extensions","isMounted","useClient","client","useState","operation","_ref2","let","currentInit","useSource","input","transform","useMemo","subject","makeSubject","concat","map","fromValue","source","nextInput","prevInput","next","state","subscribe","value","takeWhile","input$","unsubscribe","setState","prevValue","a","b","const","x","isShallowDifferent","useEffect","updateInput","useRequest","query","variables","prev","useRef","request","createRequest","current","key","isSuspense","context","suspense","sources","Map","result","partial","_extends","query$","query$$","prevState","scan","initialState","switchMap","useQuery","args","makeQuery$","useCallback","opts","get","executeQuery","requestPolicy","pollInterval","cache","resolve","shared","share","_resolve","filter","sink","onPush","Promise","toSuspenseSource","window","set","pause","update","delete","subscription$","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","mutation","useMutation","children","executeMutation","Query","Subscription","subscription"],"mappings":"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"}