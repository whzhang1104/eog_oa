function _extends() {
  return (_extends = Object.assign || function(target) {
    var i, source, key;
    for (i = 1; i < arguments.length; i++) {
      source = arguments[i];
      for (key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

function useMutation(query) {
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: !1,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions,
        operation: result.operation
      });
    }
    return result;
  }
  function _ref2() {
    isMounted.current = !1;
  }
  var isMounted = react.useRef(!0), client = useClient(), ref = react.useState(initialState), state = ref[0], setState = ref[1], executeMutation = react.useCallback((function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: !0
    }));
    return wonka.toPromise(client.executeMutation(core.createRequest(query, variables), context || {})).then(_ref);
  }), [ client, query, setState ]);
  react.useEffect((function() {
    return _ref2;
  }), []);
  return [ state, executeMutation ];
}

function _ref3() {
  return currentInit;
}

function useSource(input, transform) {
  function _ref() {
    return input;
  }
  function _ref5(value) {
    if (!currentInit) {
      setState((function _ref4(prevValue) {
        return isShallowDifferent(prevValue, value) ? value : prevValue;
      }));
    }
  }
  var ref = react.useMemo((function() {
    var subject = wonka.makeSubject(), source = wonka.concat([ wonka.map(_ref)(wonka.fromValue(input)), subject.source ]), updateInput = function(nextInput) {
      var prevInput = input;
      try {
        if (nextInput !== prevInput) {
          subject.next(input = nextInput);
        }
      } catch (error) {
        input = prevInput;
        throw error;
      }
    };
    return [ source, updateInput ];
  }), []), input$ = ref[0], updateInput = ref[1], ref$1 = react.useState((function() {
    currentInit = !0;
    var state;
    try {
      wonka.subscribe((function _ref2(value) {
        state = value;
      }))(wonka.takeWhile(_ref3)(transform(input$))).unsubscribe();
    } finally {
      currentInit = !1;
    }
    return state;
  })), state = ref$1[0], setState = ref$1[1];
  react.useEffect((function() {
    return wonka.subscribe(_ref5)(transform(input$, state)).unsubscribe;
  }), [ input$ ]);
  return [ state, updateInput ];
}

function useRequest(query, variables) {
  var prev = react.useRef(void 0);
  return react.useMemo((function() {
    var request = core.createRequest(query, variables);
    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }), [ query, variables ]);
}

function _ref3$1(x) {
  return void 0 !== x;
}

function _ref4(result, partial) {
  return _extends({}, result, partial);
}

function _ref5(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !1,
    stale: !!stale,
    data: data,
    error: error,
    operation: operation,
    extensions: extensions
  };
}

function _ref6(query$) {
  if (!query$) {
    return wonka.fromValue({
      fetching: !1,
      stale: !1
    });
  }
  return wonka.concat([ wonka.fromValue({
    fetching: !0,
    stale: !1
  }), wonka.map(_ref5)(query$), wonka.fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function _ref7(query$$, prevState) {
  return wonka.scan(_ref4, prevState || initialState)(wonka.switchMap(_ref6)(query$$));
}

function useQuery(args) {
  var client = useClient(), request = useRequest(args.query, args.variables), makeQuery$ = react.useCallback((function(opts) {
    var suspense = isSuspense(client, args.context), source = suspense ? sources.get(request.key) : void 0;
    if (!source) {
      source = client.executeQuery(request, _extends({}, {
        requestPolicy: args.requestPolicy,
        pollInterval: args.pollInterval
      }, args.context, opts));
      if (suspense) {
        source = function toSuspenseSource(source) {
          function _ref(result) {
            if (resolve && void 0 === cache) {
              resolve(result);
            }
            cache = result;
          }
          function _ref2(_resolve) {
            resolve = _resolve;
          }
          var cache, resolve, shared = wonka.share(source), suspend$ = function(sink) {
            wonka.onPush(_ref)(shared)(sink);
            if (void 0 === cache) {
              throw new Promise(_ref2);
            }
          };
          return wonka.concat([ wonka.filter(_ref3$1)(wonka.map((function() {
            return cache;
          }))(wonka.fromValue(cache))), suspend$ ]);
        }(source);
        if ("undefined" != typeof window) {
          sources.set(request.key, source);
        }
      }
    }
    return source;
  }), [ client, request, args.requestPolicy, args.pollInterval, args.context ]), query$ = react.useMemo((function() {
    return args.pause ? null : makeQuery$();
  }), [ args.pause, makeQuery$ ]), ref = useSource(query$, react.useCallback(_ref7, [])), state = ref[0], update = ref[1], executeQuery = react.useCallback((function(opts) {
    update(makeQuery$(_extends({}, {
      suspense: !1
    }, opts)));
  }), [ update, makeQuery$ ]);
  react.useEffect((function() {
    sources.delete(request.key);
    if (!isSuspense(client, args.context)) {
      update(query$);
    }
  }), [ update, client, query$, request, args.context ]);
  if (isSuspense(client, args.context)) {
    update(query$);
  }
  return [ state, executeQuery ];
}

function _ref2(ref) {
  var stale = ref.stale, data = ref.data, error = ref.error, extensions = ref.extensions, operation = ref.operation;
  return {
    fetching: !0,
    stale: !!stale,
    data: data,
    error: error,
    extensions: extensions,
    operation: operation
  };
}

function _ref3$2(subscription$) {
  if (!subscription$) {
    return wonka.fromValue({
      fetching: !1
    });
  }
  return wonka.concat([ wonka.fromValue({
    fetching: !0,
    stale: !1
  }), wonka.map(_ref2)(subscription$), wonka.fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

function useSubscription(args, handler) {
  function _ref(result, partial) {
    var handler = handlerRef.current, data = void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;
    return _extends({}, result, partial, {
      data: data
    });
  }
  var request, makeSubscription$, subscription$, ref, state, update, executeSubscription, client = useClient(), handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  request = useRequest(args.query, args.variables);
  makeSubscription$ = react.useCallback((function(opts) {
    return client.executeSubscription(request, _extends({}, args.context, opts));
  }), [ client, request, args.context ]);
  state = (ref = useSource(subscription$ = react.useMemo((function() {
    return args.pause ? null : makeSubscription$();
  }), [ args.pause, makeSubscription$ ]), react.useCallback((function(subscription$$, prevState) {
    return wonka.scan(_ref, prevState || initialState)(wonka.switchMap(_ref3$2)(subscription$$));
  }), [])))[0];
  executeSubscription = react.useCallback((function(opts) {
    return update(makeSubscription$(opts));
  }), [ update = ref[1], makeSubscription$ ]);
  react.useEffect((function() {
    update(subscription$);
  }), [ update, subscription$ ]);
  return [ state, executeSubscription ];
}

var core = require("@urql/core"), react = require("react"), wonka = require("wonka"), defaultClient = core.createClient({
  url: "/graphql"
}), Context = react.createContext(defaultClient), Provider = Context.Provider, Consumer = Context.Consumer, hasWarnedAboutDefault = !1, useClient = function() {
  var client = react.useContext(Context);
  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
}, initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0,
  operation: void 0
}, currentInit = !1, isShallowDifferent = function(a, b) {
  var x, x$1;
  if ("object" != typeof a || "object" != typeof b) {
    return a !== b;
  }
  for (x in a) {
    if (!(x in b)) {
      return !0;
    }
  }
  for (x$1 in b) {
    if (a[x$1] !== b[x$1]) {
      return !0;
    }
  }
  return !1;
}, isSuspense = function(client, context) {
  return client.suspense && (!context || !1 !== context.suspense);
}, sources = new Map;

Object.keys(core).forEach((function(k) {
  if ("default" !== k) {
    exports[k] = core[k];
  }
}));

exports.Consumer = Consumer;

exports.Context = Context;

exports.Mutation = function Mutation(props) {
  var mutation = useMutation(props.query);
  return props.children(_extends({}, mutation[0], {
    executeMutation: mutation[1]
  }));
};

exports.Provider = Provider;

exports.Query = function Query(props) {
  var query = useQuery(props);
  return props.children(_extends({}, query[0], {
    executeQuery: query[1]
  }));
};

exports.Subscription = function Subscription(props) {
  var subscription = useSubscription(props, props.handler);
  return props.children(_extends({}, subscription[0], {
    executeSubscription: subscription[1]
  }));
};

exports.useClient = useClient;

exports.useMutation = useMutation;

exports.useQuery = useQuery;

exports.useSubscription = useSubscription;
//# sourceMappingURL=urql.js.map
