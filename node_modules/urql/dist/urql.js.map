{"version":3,"file":"urql.js","sources":["../src/hooks/useMutation.ts","../src/hooks/useSource.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/context.ts","../src/hooks/constants.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect, useState } from 'react';\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  takeWhile,\n  pipe,\n  map,\n  concat,\n  subscribe,\n} from 'wonka';\n\ntype Updater<T> = (input: T) => void;\n\nlet currentInit = false;\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\nexport function useSource<T, R>(\n  input: T,\n  transform: (input$: Source<T>, initial?: R) => Source<R>\n): [R, Updater<T>] {\n  const [input$, updateInput] = useMemo((): [Source<T>, (value: T) => void] => {\n    const subject = makeSubject<T>();\n    const source = concat([\n      pipe(\n        fromValue(input),\n        map(() => input)\n      ),\n      subject.source,\n    ]);\n\n    const updateInput = (nextInput: T) => {\n      const prevInput = input;\n      try {\n        if (nextInput !== prevInput) subject.next((input = nextInput));\n      } catch (error) {\n        // If we suspend then React will preserve the component's state\n        // which means we'll need to prepare that the next update must be\n        // able to retrigger an update of the input.\n        input = prevInput;\n        throw error;\n      }\n    };\n\n    return [source, updateInput];\n  }, []);\n\n  const [state, setState] = useState<R>(() => {\n    currentInit = true;\n    let state: R;\n    try {\n      pipe(\n        transform(input$),\n        takeWhile(() => currentInit),\n        subscribe(value => {\n          state = value;\n        })\n      ).unsubscribe();\n    } finally {\n      currentInit = false;\n    }\n\n    return state!;\n  });\n\n  useEffect(() => {\n    return pipe(\n      transform(input$, state),\n      subscribe(value => {\n        if (!currentInit) {\n          setState(prevValue => {\n            return isShallowDifferent(prevValue, value) ? value : prevValue;\n          });\n        }\n      })\n    ).unsubscribe;\n  }, [input$ /* `state` is only an initialiser */]);\n\n  return [state, updateInput];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  Source,\n  pipe,\n  share,\n  concat,\n  onPush,\n  fromValue,\n  switchMap,\n  filter,\n  map,\n  scan,\n} from 'wonka';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\n/** Convert the Source to a React Suspense source on demand */\nfunction toSuspenseSource<T>(source: Source<T>): Source<T> {\n  const shared = share(source);\n  let cache: T | undefined;\n  let resolve: (value: T) => void;\n\n  const suspend$: Source<T> = sink => {\n    pipe(\n      shared,\n      onPush(result => {\n        // The first result that is received will resolve the Suspense promise\n        if (resolve && cache === undefined) resolve(result);\n        cache = result;\n      })\n    )(sink);\n\n    // If we haven't got a previous result then throw a Suspense promise\n    if (cache === undefined) {\n      throw new Promise<T>(_resolve => {\n        resolve = _resolve;\n      });\n    }\n  };\n\n  return concat([\n    pipe(\n      fromValue<T>(cache!),\n      map<T, T>(() => cache!),\n      filter(x => x !== undefined)\n    ),\n    suspend$,\n  ]);\n}\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nconst sources = new Map<number, Source<OperationResult>>();\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      // Determine whether suspense is enabled for the given operation\n      const suspense = isSuspense(client, args.context);\n      let source: Source<OperationResult> | void = suspense\n        ? sources.get(request.key)\n        : undefined;\n\n      if (!source) {\n        source = client.executeQuery(request, {\n          requestPolicy: args.requestPolicy,\n          pollInterval: args.pollInterval,\n          ...args.context,\n          ...opts,\n        });\n\n        // Create a suspense source and cache it for the given request\n        if (suspense) {\n          source = toSuspenseSource(source);\n          if (typeof window !== 'undefined') {\n            sources.set(request.key, source);\n          }\n        }\n      }\n\n      return source;\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const query$ = useMemo(() => {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]);\n\n  const [state, update] = useSource(\n    query$,\n    useCallback((query$$, prevState?: UseQueryState<Data, Variables>) => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result: UseQueryState<Data, Variables>, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          prevState || initialState\n        )\n      );\n    }, [])\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      update(makeQuery$({ suspense: false, ...opts }));\n    },\n    [update, makeQuery$]\n  );\n\n  useEffect(() => {\n    sources.delete(request.key); // Delete any cached suspense source\n    if (!isSuspense(client, args.context)) update(query$);\n  }, [update, client, query$, request, args.context]);\n\n  if (isSuspense(client, args.context)) update(query$);\n\n  return [state, executeQuery];\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler!;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription<Data, Variables>(request, {\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.context]\n  );\n\n  const subscription$ = useMemo(() => {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]);\n\n  const [state, update] = useSource(\n    subscription$,\n    useCallback(\n      (subscription$$, prevState?: UseSubscriptionState<Result, Variables>) => {\n        return pipe(\n          subscription$$,\n          switchMap(subscription$ => {\n            if (!subscription$) return fromValue({ fetching: false });\n\n            return concat([\n              // Initially set fetching to true\n              fromValue({ fetching: true, stale: false }),\n              pipe(\n                subscription$,\n                map(({ stale, data, error, extensions, operation }) => ({\n                  fetching: true,\n                  stale: !!stale,\n                  data,\n                  error,\n                  extensions,\n                  operation,\n                }))\n              ),\n              // When the source proactively closes, fetching is set to false\n              fromValue({ fetching: false, stale: false }),\n            ]);\n          }),\n          // The individual partial results are merged into each previous result\n          scan(\n            (result: UseSubscriptionState<Result, Variables>, partial: any) => {\n              const { current: handler } = handlerRef;\n              // If a handler has been passed, it's used to merge new data in\n              const data =\n                partial.data !== undefined\n                  ? typeof handler === 'function'\n                    ? handler(result.data, partial.data)\n                    : partial.data\n                  : result.data;\n              return { ...result, ...partial, data };\n            },\n            prevState || initialState\n          )\n        );\n      },\n      []\n    )\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  useEffect(() => {\n    update(subscription$);\n  }, [update, subscription$]);\n\n  return [state, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],"names":["const","fetching","current","data","error","extensions","operation","query","client","useEffect","useSource","updateInput","ref","request","toSuspenseSource","wonka","useCallback","opts","suspense","undefined","context","let","_resolve","sink","shared","args","requestPolicy","useMemo","executeQuery","delete","subscription$","executeSubscription","handlerRef","result","partial","update","Mutation","Provider","Consumer","Context","hasWarnedAboutDefault","useClient","process","x","b","executeMutation"],"mappings":";;;;;;;;;;;;;;;AAqCEA;;QAmBUC,UAAUC;eACH;QACPC;QACAC;QACAC;QACAC;QANFD;;;;;;;;;EAlBRL,+HAQgCC;;;;WAuBrBM,gBAzBwBC;;QA4BnCC;;;;;;;SC9CcC;;;AASO;;;;;;;;;;;EAAA;QAKbC;;;QAIF;;;;;;;;;oBAaOC;;;;;;;;;;;;;IAiBb;;;;;AC7DEZ;;;kBAGcE;;aAGLW;;MAEPN,KAADL;;;;;;;oBCmCIY;;;;;;;;0EA8F6DF,4BAAAA;;;;;;;;;;;AAP5BX;;;;;;;SAIGc;;IAarBd;;;;;;;AApBlB;;;;;MAxCEY,2FAOmDG,sBAC9BC;QAGnBC,iGACoCC;;;;;cAS9BC;;iBA9DdC;;;;;;;;sBAEcC;;UAFdD,sEAaEE;+BACQC;;;;;;;;SAkDOV;;;;;;WAWRW;MACN,EAACA,sBAADC,kEAE8BC;;0FAuC3BC,YAAY;;;;;QASZnB;YAAyCoB,OAAAhB;oBAC5CL,QAAAiB;;;;;;;;;;;sGCtGmEb;;;;;;;;;;;AAPrBX;;;;;;SAIJc;;IAarBd;;;;;;;;;;;;;;eA5BlB6B,uCAqDAC,oCAvEAC;aAKO9B;;EAaP4B;WACGL;MACN,EAACA;EAmDEM;gBApBKE,QAAiDC;;;;;IA0B1DC,OAAOL;MACN,mBAASA;;;;SCvGEM;;;;ECjBhBpC;IAGaqC,8CACAC,WAAWC,QAAQD,UAE5BE,6BAESC;MAITC;;;;;;;ECdFtC;EACAD;EACAE;EACAC;;;kBNagB;;;WACLqC,MAAXC;;;;;;;;;;;;;;;;;;;;;;;;;;;mBIMwCC;;;;;;;;;gBGRHjB;;;;;;;uBCgBnCG;;;;;;;;;;;;;"}