{"ast":null,"code":"function _extends() {\n  return (_extends = Object.assign || function (target) {\n    var i, source, key;\n\n    for (i = 1; i < arguments.length; i++) {\n      source = arguments[i];\n\n      for (key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  }).apply(this, arguments);\n}\n\nfunction useMutation(query) {\n  function _ref(result) {\n    if (isMounted.current) {\n      setState({\n        fetching: !1,\n        stale: !!result.stale,\n        data: result.data,\n        error: result.error,\n        extensions: result.extensions,\n        operation: result.operation\n      });\n    }\n\n    return result;\n  }\n\n  function _ref2() {\n    isMounted.current = !1;\n  }\n\n  var isMounted = useRef(!0),\n      client = useClient(),\n      ref = useState(initialState),\n      state = ref[0],\n      setState = ref[1],\n      executeMutation = useCallback(function (variables, context) {\n    setState(_extends({}, initialState, {\n      fetching: !0\n    }));\n    return toPromise(client.executeMutation(createRequest(query, variables), context || {})).then(_ref);\n  }, [client, query, setState]);\n  useEffect(function () {\n    return _ref2;\n  }, []);\n  return [state, executeMutation];\n}\n\nfunction _ref3() {\n  return currentInit;\n}\n\nfunction useSource(input, transform) {\n  function _ref() {\n    return input;\n  }\n\n  function _ref5(value) {\n    if (!currentInit) {\n      setState(function _ref4(prevValue) {\n        return isShallowDifferent(prevValue, value) ? value : prevValue;\n      });\n    }\n  }\n\n  var ref = useMemo(function () {\n    var subject = makeSubject(),\n        source = concat([map(_ref)(fromValue(input)), subject.source]),\n        updateInput = function updateInput(nextInput) {\n      var prevInput = input;\n\n      try {\n        if (nextInput !== prevInput) {\n          subject.next(input = nextInput);\n        }\n      } catch (error) {\n        input = prevInput;\n        throw error;\n      }\n    };\n\n    return [source, updateInput];\n  }, []),\n      input$ = ref[0],\n      updateInput = ref[1],\n      ref$1 = useState(function () {\n    currentInit = !0;\n    var state;\n\n    try {\n      subscribe(function _ref2(value) {\n        state = value;\n      })(takeWhile(_ref3)(transform(input$))).unsubscribe();\n    } finally {\n      currentInit = !1;\n    }\n\n    return state;\n  }),\n      state = ref$1[0],\n      setState = ref$1[1];\n  useEffect(function () {\n    return subscribe(_ref5)(transform(input$, state)).unsubscribe;\n  }, [input$]);\n  return [state, updateInput];\n}\n\nfunction useRequest(query, variables) {\n  var prev = useRef(void 0);\n  return useMemo(function () {\n    var request = createRequest(query, variables);\n\n    if (void 0 !== prev.current && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n\nfunction _ref3$1(x) {\n  return void 0 !== x;\n}\n\nfunction _ref4(result, partial) {\n  return _extends({}, result, partial);\n}\n\nfunction _ref5(ref) {\n  var stale = ref.stale,\n      data = ref.data,\n      error = ref.error,\n      extensions = ref.extensions,\n      operation = ref.operation;\n  return {\n    fetching: !1,\n    stale: !!stale,\n    data: data,\n    error: error,\n    operation: operation,\n    extensions: extensions\n  };\n}\n\nfunction _ref6(query$) {\n  if (!query$) {\n    return fromValue({\n      fetching: !1,\n      stale: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0,\n    stale: !1\n  }), map(_ref5)(query$), fromValue({\n    fetching: !1,\n    stale: !1\n  })]);\n}\n\nfunction _ref7(query$$, prevState) {\n  return scan(_ref4, prevState || initialState)(switchMap(_ref6)(query$$));\n}\n\nfunction useQuery(args) {\n  var client = useClient(),\n      request = useRequest(args.query, args.variables),\n      makeQuery$ = useCallback(function (opts) {\n    var suspense = isSuspense(client, args.context),\n        source = suspense ? sources.get(request.key) : void 0;\n\n    if (!source) {\n      source = client.executeQuery(request, _extends({}, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval\n      }, args.context, opts));\n\n      if (suspense) {\n        source = function toSuspenseSource(source) {\n          function _ref(result) {\n            if (resolve && void 0 === cache) {\n              resolve(result);\n            }\n\n            cache = result;\n          }\n\n          function _ref2(_resolve) {\n            resolve = _resolve;\n          }\n\n          var cache,\n              resolve,\n              shared = share(source),\n              suspend$ = function suspend$(sink) {\n            onPush(_ref)(shared)(sink);\n\n            if (void 0 === cache) {\n              throw new Promise(_ref2);\n            }\n          };\n\n          return concat([filter(_ref3$1)(map(function () {\n            return cache;\n          })(fromValue(cache))), suspend$]);\n        }(source);\n\n        if (\"undefined\" != typeof window) {\n          sources.set(request.key, source);\n        }\n      }\n    }\n\n    return source;\n  }, [client, request, args.requestPolicy, args.pollInterval, args.context]),\n      query$ = useMemo(function () {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]),\n      ref = useSource(query$, useCallback(_ref7, [])),\n      state = ref[0],\n      update = ref[1],\n      executeQuery = useCallback(function (opts) {\n    update(makeQuery$(_extends({}, {\n      suspense: !1\n    }, opts)));\n  }, [update, makeQuery$]);\n  useEffect(function () {\n    sources.delete(request.key);\n\n    if (!isSuspense(client, args.context)) {\n      update(query$);\n    }\n  }, [update, client, query$, request, args.context]);\n\n  if (isSuspense(client, args.context)) {\n    update(query$);\n  }\n\n  return [state, executeQuery];\n}\n\nfunction _ref2(ref) {\n  var stale = ref.stale,\n      data = ref.data,\n      error = ref.error,\n      extensions = ref.extensions,\n      operation = ref.operation;\n  return {\n    fetching: !0,\n    stale: !!stale,\n    data: data,\n    error: error,\n    extensions: extensions,\n    operation: operation\n  };\n}\n\nfunction _ref3$2(subscription$) {\n  if (!subscription$) {\n    return fromValue({\n      fetching: !1\n    });\n  }\n\n  return concat([fromValue({\n    fetching: !0,\n    stale: !1\n  }), map(_ref2)(subscription$), fromValue({\n    fetching: !1,\n    stale: !1\n  })]);\n}\n\nfunction useSubscription(args, handler) {\n  function _ref(result, partial) {\n    var handler = handlerRef.current,\n        data = void 0 !== partial.data ? \"function\" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data;\n    return _extends({}, result, partial, {\n      data: data\n    });\n  }\n\n  var request,\n      makeSubscription$,\n      subscription$,\n      ref,\n      state,\n      update,\n      executeSubscription,\n      client = useClient(),\n      handlerRef = useRef(handler);\n  handlerRef.current = handler;\n  request = useRequest(args.query, args.variables);\n  makeSubscription$ = useCallback(function (opts) {\n    return client.executeSubscription(request, _extends({}, args.context, opts));\n  }, [client, request, args.context]);\n  state = (ref = useSource(subscription$ = useMemo(function () {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]), useCallback(function (subscription$$, prevState) {\n    return scan(_ref, prevState || initialState)(switchMap(_ref3$2)(subscription$$));\n  }, [])))[0];\n  executeSubscription = useCallback(function (opts) {\n    return update(makeSubscription$(opts));\n  }, [update = ref[1], makeSubscription$]);\n  useEffect(function () {\n    update(subscription$);\n  }, [update, subscription$]);\n  return [state, executeSubscription];\n}\n\nfunction Mutation(props) {\n  var mutation = useMutation(props.query);\n  return props.children(_extends({}, mutation[0], {\n    executeMutation: mutation[1]\n  }));\n}\n\nfunction Query(props) {\n  var query = useQuery(props);\n  return props.children(_extends({}, query[0], {\n    executeQuery: query[1]\n  }));\n}\n\nfunction Subscription(props) {\n  var subscription = useSubscription(props, props.handler);\n  return props.children(_extends({}, subscription[0], {\n    executeSubscription: subscription[1]\n  }));\n}\n\nvar defaultClient, Context, Provider, Consumer, hasWarnedAboutDefault, useClient, initialState, currentInit, isShallowDifferent, isSuspense, sources;\nimport { createClient, createRequest } from \"@urql/core\";\nexport * from \"@urql/core\";\nimport { createContext, useContext, useRef, useState, useCallback, useEffect, useMemo } from \"react\";\nimport { toPromise, makeSubject, concat, map, fromValue, subscribe, takeWhile, filter, share, onPush, scan, switchMap } from \"wonka\";\ndefaultClient = createClient({\n  url: \"/graphql\"\n});\nProvider = (Context = createContext(defaultClient)).Provider;\nConsumer = Context.Consumer;\nhasWarnedAboutDefault = !1;\n\nuseClient = function useClient() {\n  var client = useContext(Context);\n\n  if (\"production\" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {\n    hasWarnedAboutDefault = !0;\n    console.warn(\"Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\\nIf that's not what you want, please create a client and add a Provider.\");\n  }\n\n  return client;\n};\n\ninitialState = {\n  fetching: !1,\n  stale: !1,\n  error: void 0,\n  data: void 0,\n  extensions: void 0,\n  operation: void 0\n};\ncurrentInit = !1;\n\nisShallowDifferent = function isShallowDifferent(a, b) {\n  var x, x$1;\n\n  if (\"object\" != typeof a || \"object\" != typeof b) {\n    return a !== b;\n  }\n\n  for (x in a) {\n    if (!(x in b)) {\n      return !0;\n    }\n  }\n\n  for (x$1 in b) {\n    if (a[x$1] !== b[x$1]) {\n      return !0;\n    }\n  }\n\n  return !1;\n};\n\nisSuspense = function isSuspense(client, context) {\n  return client.suspense && (!context || !1 !== context.suspense);\n};\n\nsources = new Map();\nexport { Consumer, Context, Mutation, Provider, Query, Subscription, useClient, useMutation, useQuery, useSubscription };","map":{"version":3,"sources":["../src/hooks/useMutation.ts","../src/hooks/useSource.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts","../src/context.ts","../src/hooks/constants.ts"],"names":["isMounted","useClient","client","useState","extensions","fetching","stale","data","error","operation","_ref2","currentInit","isShallowDifferent","a","b","x","useSource","input","transform","useMemo","subject","makeSubject","source","concat","fromValue","map","updateInput","nextInput","prevInput","next","state","input$","takeWhile","subscribe","value","unsubscribe","useEffect","setState","prevValue","useRequest","query","variables","prev","useRef","undefined","request","createRequest","current","key","toSuspenseSource","shared","share","cache","resolve","suspend$","sink","onPush","result","Promise","_resolve","filter","isSuspense","context","suspense","sources","Map","useQuery","args","makeQuery$","useCallback","opts","get","executeQuery","_extends","requestPolicy","pollInterval","window","set","query$","pause","query$$","prevState","switchMap","scan","partial","initialState","update","delete","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$","subscription$$","Mutation","props","mutation","useMutation","children","executeMutation","Query","Subscription","subscription","Context","Provider","hasWarnedAboutDefault"],"mappings":"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","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect, useState } from 'react';\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  takeWhile,\n  pipe,\n  map,\n  concat,\n  subscribe,\n} from 'wonka';\n\ntype Updater<T> = (input: T) => void;\n\nlet currentInit = false;\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\nexport function useSource<T, R>(\n  input: T,\n  transform: (input$: Source<T>, initial?: R) => Source<R>\n): [R, Updater<T>] {\n  const [input$, updateInput] = useMemo((): [Source<T>, (value: T) => void] => {\n    const subject = makeSubject<T>();\n    const source = concat([\n      pipe(\n        fromValue(input),\n        map(() => input)\n      ),\n      subject.source,\n    ]);\n\n    const updateInput = (nextInput: T) => {\n      const prevInput = input;\n      try {\n        if (nextInput !== prevInput) subject.next((input = nextInput));\n      } catch (error) {\n        // If we suspend then React will preserve the component's state\n        // which means we'll need to prepare that the next update must be\n        // able to retrigger an update of the input.\n        input = prevInput;\n        throw error;\n      }\n    };\n\n    return [source, updateInput];\n  }, []);\n\n  const [state, setState] = useState<R>(() => {\n    currentInit = true;\n    let state: R;\n    try {\n      pipe(\n        transform(input$),\n        takeWhile(() => currentInit),\n        subscribe(value => {\n          state = value;\n        })\n      ).unsubscribe();\n    } finally {\n      currentInit = false;\n    }\n\n    return state!;\n  });\n\n  useEffect(() => {\n    return pipe(\n      transform(input$, state),\n      subscribe(value => {\n        if (!currentInit) {\n          setState(prevValue => {\n            return isShallowDifferent(prevValue, value) ? value : prevValue;\n          });\n        }\n      })\n    ).unsubscribe;\n  }, [input$ /* `state` is only an initialiser */]);\n\n  return [state, updateInput];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useMemo } from 'react';\n\nimport {\n  Source,\n  pipe,\n  share,\n  concat,\n  onPush,\n  fromValue,\n  switchMap,\n  filter,\n  map,\n  scan,\n} from 'wonka';\n\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\n/** Convert the Source to a React Suspense source on demand */\nfunction toSuspenseSource<T>(source: Source<T>): Source<T> {\n  const shared = share(source);\n  let cache: T | undefined;\n  let resolve: (value: T) => void;\n\n  const suspend$: Source<T> = sink => {\n    pipe(\n      shared,\n      onPush(result => {\n        // The first result that is received will resolve the Suspense promise\n        if (resolve && cache === undefined) resolve(result);\n        cache = result;\n      })\n    )(sink);\n\n    // If we haven't got a previous result then throw a Suspense promise\n    if (cache === undefined) {\n      throw new Promise<T>(_resolve => {\n        resolve = _resolve;\n      });\n    }\n  };\n\n  return concat([\n    pipe(\n      fromValue<T>(cache!),\n      map<T, T>(() => cache!),\n      filter(x => x !== undefined)\n    ),\n    suspend$,\n  ]);\n}\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nconst sources = new Map<number, Source<OperationResult>>();\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      // Determine whether suspense is enabled for the given operation\n      const suspense = isSuspense(client, args.context);\n      let source: Source<OperationResult> | void = suspense\n        ? sources.get(request.key)\n        : undefined;\n\n      if (!source) {\n        source = client.executeQuery(request, {\n          requestPolicy: args.requestPolicy,\n          pollInterval: args.pollInterval,\n          ...args.context,\n          ...opts,\n        });\n\n        // Create a suspense source and cache it for the given request\n        if (suspense) {\n          source = toSuspenseSource(source);\n          if (typeof window !== 'undefined') {\n            sources.set(request.key, source);\n          }\n        }\n      }\n\n      return source;\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const query$ = useMemo(() => {\n    return args.pause ? null : makeQuery$();\n  }, [args.pause, makeQuery$]);\n\n  const [state, update] = useSource(\n    query$,\n    useCallback((query$$, prevState?: UseQueryState<Data, Variables>) => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions, operation }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                operation,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result: UseQueryState<Data, Variables>, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          prevState || initialState\n        )\n      );\n    }, [])\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      update(makeQuery$({ suspense: false, ...opts }));\n    },\n    [update, makeQuery$]\n  );\n\n  useEffect(() => {\n    sources.delete(request.key); // Delete any cached suspense source\n    if (!isSuspense(client, args.context)) update(query$);\n  }, [update, client, query$, request, args.context]);\n\n  if (isSuspense(client, args.context)) update(query$);\n\n  return [state, executeQuery];\n}\n","import { DocumentNode } from 'graphql';\nimport { useEffect, useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler!;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription<Data, Variables>(request, {\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.context]\n  );\n\n  const subscription$ = useMemo(() => {\n    return args.pause ? null : makeSubscription$();\n  }, [args.pause, makeSubscription$]);\n\n  const [state, update] = useSource(\n    subscription$,\n    useCallback(\n      (subscription$$, prevState?: UseSubscriptionState<Result, Variables>) => {\n        return pipe(\n          subscription$$,\n          switchMap(subscription$ => {\n            if (!subscription$) return fromValue({ fetching: false });\n\n            return concat([\n              // Initially set fetching to true\n              fromValue({ fetching: true, stale: false }),\n              pipe(\n                subscription$,\n                map(({ stale, data, error, extensions, operation }) => ({\n                  fetching: true,\n                  stale: !!stale,\n                  data,\n                  error,\n                  extensions,\n                  operation,\n                }))\n              ),\n              // When the source proactively closes, fetching is set to false\n              fromValue({ fetching: false, stale: false }),\n            ]);\n          }),\n          // The individual partial results are merged into each previous result\n          scan(\n            (result: UseSubscriptionState<Result, Variables>, partial: any) => {\n              const { current: handler } = handlerRef;\n              // If a handler has been passed, it's used to merge new data in\n              const data =\n                partial.data !== undefined\n                  ? typeof handler === 'function'\n                    ? handler(result.data, partial.data)\n                    : partial.data\n                  : result.data;\n              return { ...result, ...partial, data };\n            },\n            prevState || initialState\n          )\n        );\n      },\n      []\n    )\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  useEffect(() => {\n    update(subscription$);\n  }, [update, subscription$]);\n\n  return [state, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n","import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n"]},"metadata":{},"sourceType":"module"}