{"ast":null,"code":"function k(a) {\n  return \"string\" == typeof a ? new GraphQLError(a) : \"object\" == typeof a && a.message ? new GraphQLError(a.message, a.nodes, a.source, a.positions, a.path, a, a.extensions || {}) : a;\n}\n\nfunction l() {\n  return this.message;\n}\n\nfunction n(a, b) {\n  a |= 0;\n\n  for (var c = 0, d = 0 | b.length; c < d; c++) {\n    a = (a << 5) + a + b.charCodeAt(c);\n  }\n\n  return a;\n}\n\nfunction t(a) {\n  var b, c, d, e, f, g;\n\n  if (null === a || q.has(a)) {\n    return \"null\";\n  }\n\n  if (\"object\" != typeof a) {\n    return JSON.stringify(a) || \"\";\n  }\n\n  if (a.toJSON) {\n    return t(a.toJSON());\n  }\n\n  if (Array.isArray(a)) {\n    for (b = \"[\", c = 0, d = a.length; c < d; c++) {\n      0 < c && (b += \",\");\n      b += 0 < (e = t(a[c])).length ? e : \"null\";\n    }\n\n    return b + \"]\";\n  }\n\n  if (!(b = Object.keys(a).sort()).length && a.constructor && a.constructor !== Object) {\n    return b = r.get(a) || Math.random().toString(36).slice(2), r.set(a, b), '{\"__key\":\"' + b + '\"}';\n  }\n\n  q.add(a);\n  c = \"{\";\n  d = 0;\n\n  for (e = b.length; d < e; d++) {\n    (g = t(a[f = b[d]])) && (1 < c.length && (c += \",\"), c += t(f) + \":\" + g);\n  }\n\n  q.delete(a);\n  return c + \"}\";\n}\n\nfunction u(a) {\n  q.clear();\n  return t(a);\n}\n\nfunction v(a) {\n  var b = (\"string\" != typeof a ? a.loc && a.loc.source.body || print(a) : a).replace(/([\\s,]|#[^\\n\\r]+)+/g, \" \").trim();\n  \"string\" != typeof a && (a.loc ? (a = \"definitions\" in a && w(a)) && (b = \"# \" + a + \"\\n\" + b) : a.loc = {\n    start: 0,\n    end: b.length,\n    source: {\n      body: b,\n      name: \"gql\",\n      locationOffset: {\n        line: 1,\n        column: 1\n      }\n    }\n  });\n  return b;\n}\n\nfunction y(a) {\n  if (\"string\" == typeof a) {\n    var b = n(5381, v(a)) >>> 0;\n    a = x.get(b) || parse(a, {\n      noLocation: !0\n    });\n  } else {\n    b = a.__key || n(5381, v(a)) >>> 0, a = x.get(b) || a;\n  }\n\n  a.loc || v(a);\n  a.__key = b;\n  x.set(b, a);\n  return a;\n}\n\nfunction w(a) {\n  var b, c, d;\n\n  for (b = 0, c = a.definitions.length; b < c; b++) {\n    if ((d = a.definitions[b]).kind === Kind.OPERATION_DEFINITION && d.name) {\n      return d.name.value;\n    }\n  }\n}\n\nfunction z(a, b, c) {\n  return {\n    operation: a,\n    data: b.data,\n    error: Array.isArray(b.errors) ? new m({\n      graphQLErrors: b.errors,\n      response: c\n    }) : void 0,\n    extensions: \"object\" == typeof b.extensions && b.extensions || void 0\n  };\n}\n\nfunction A(a, b, c) {\n  return {\n    operation: a,\n    data: void 0,\n    error: new m({\n      networkError: b,\n      response: c\n    }),\n    extensions: void 0\n  };\n}\n\nfunction B() {\n  return (B = Object.assign || function (a) {\n    var b, c, d;\n\n    for (b = 1; b < arguments.length; b++) {\n      c = arguments[b];\n\n      for (d in c) {\n        Object.prototype.hasOwnProperty.call(c, d) && (a[d] = c[d]);\n      }\n    }\n\n    return a;\n  }).apply(this, arguments);\n}\n\nfunction makeFetchBody(a) {\n  return {\n    query: print(a.query),\n    operationName: w(a.query),\n    variables: a.variables || void 0,\n    extensions: void 0\n  };\n}\n\nfunction makeFetchURL(a, b) {\n  var c = a.context.url;\n\n  if (\"query\" !== a.kind || !a.context.preferGetMethod || !b) {\n    return c;\n  }\n\n  a = [];\n  b.operationName && a.push(\"operationName=\" + encodeURIComponent(b.operationName));\n  b.query && a.push(\"query=\" + encodeURIComponent(b.query.replace(/([\\s,]|#[^\\n\\r]+)+/g, \" \").trim()));\n  b.variables && a.push(\"variables=\" + encodeURIComponent(u(b.variables)));\n  b.extensions && a.push(\"extensions=\" + encodeURIComponent(u(b.extensions)));\n  return c + \"?\" + a.join(\"&\");\n}\n\nfunction makeFetchOptions(a, b) {\n  var c = \"query\" === a.kind && !!a.context.preferGetMethod;\n  return B({}, a = \"function\" == typeof a.context.fetchOptions ? a.context.fetchOptions() : a.context.fetchOptions || {}, {\n    body: !c && b ? JSON.stringify(b) : void 0,\n    method: c ? \"GET\" : \"POST\",\n    headers: c ? a.headers : B({}, {\n      \"content-type\": \"application/json\"\n    }, a.headers)\n  });\n}\n\nfunction makeFetchSource(a, b, c) {\n  return make(function (d) {\n    var e = d.next,\n        f = d.complete,\n        g = \"undefined\" != typeof AbortController ? new AbortController() : null,\n        p = !1;\n    Promise.resolve().then(function () {\n      if (!p) {\n        return g && (c.signal = g.signal), function C(a, b, c) {\n          var e,\n              d = !1;\n          return (a.context.fetch || fetch)(b, c).then(function (a) {\n            e = a;\n            d = 200 > a.status || a.status >= (\"manual\" === c.redirect ? 400 : 300);\n            return a.json();\n          }).then(function (b) {\n            if (!(\"data\" in b) && !(\"errors\" in b)) {\n              throw Error(\"No Content\");\n            }\n\n            return z(a, b, e);\n          }).catch(function (b) {\n            if (\"AbortError\" !== b.name) {\n              return A(a, d ? Error(e.statusText) : b, e);\n            }\n          });\n        }(a, b, c);\n      }\n    }).then(function (a) {\n      p || (p = !0, a && e(a), f());\n    });\n    return function () {\n      p = !0;\n      g && g.abort();\n    };\n  });\n}\n\nfunction createRequest(a, b) {\n  a = y(a);\n  return {\n    key: b ? n(a.__key, u(b)) >>> 0 : a.__key,\n    query: a,\n    variables: b || {}\n  };\n}\n\nvar m, q, r, x;\nimport { make } from \"wonka\";\nimport { GraphQLError } from \"graphql/error/GraphQLError.mjs\";\nimport { Kind } from \"graphql/language/kinds.mjs\";\nimport { parse } from \"graphql/language/parser.mjs\";\nimport { print } from \"graphql/language/printer.mjs\";\n\nm = function (a) {\n  function b(b) {\n    var f,\n        c = b.networkError,\n        e = b.response;\n\n    f = function h(a, b) {\n      var d = \"\";\n\n      if (void 0 !== a) {\n        return d = \"[Network] \" + a.message;\n      }\n\n      void 0 !== b && b.forEach(function c(a) {\n        d += \"[GraphQL] \" + a.message + \"\\n\";\n      });\n      return d.trim();\n    }(c, b = (b.graphQLErrors || []).map(k));\n\n    a.call(this, f);\n    this.name = \"CombinedError\";\n    this.message = f;\n    this.graphQLErrors = b;\n    this.networkError = c;\n    this.response = e;\n  }\n\n  a && (b.__proto__ = a);\n  (b.prototype = Object.create(a && a.prototype)).constructor = b;\n  b.prototype.toString = l;\n  return b;\n}(Error);\n\nq = new Set(), r = new WeakMap();\nx = new Map();\nexport { m as C, B as _, A as a, makeFetchBody as b, makeFetchURL as c, makeFetchOptions as d, makeFetchSource as e, createRequest as f, u as g, w as h, y as k, z as m, v as s };","map":{"version":3,"sources":["../src/utils/error.ts","../src/utils/stringifyVariables.ts","../src/utils/request.ts","../src/utils/result.ts","../src/internal/fetchSource.ts","../src/internal/fetchOptions.ts","../src/utils/hash.ts"],"names":["error","parse","normalizedGraphQLErrors","b","x","Array","cache","keys","seen","stringify","node","stringifyDocument","docs","toString","keyDocument","vars","query","operation","y","Error","statusNotOk","v","response","Promise","ended","body","url","useGETMethod","graphQLErrors","c","h"],"mappings":"AAuDUE,SAAAA,CAAAA,CAAAA,CAAAA,EAAAA;;;;;;;;ACjDD,SAAA,CAAA,CAAA,CAAA,EAAA,CAAA,EAAA;OAEIE,C;;;mBAEAC,C,GAAkBF,CAAAA,CAAAA,UAAAA,CAAAA,CAAAA,C;;;;;;;;;eAcfG,C,IAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,C,EAAAA;;;;MAOD,YAAA,OAAA,C,EAAA;WAAOC,IAAAA,CAAAA,SAAAA,CAAAA,CAAAA,KAAyB,E;;;;WASjCH,CAAAA,CAAZI,CAAAA,CAAAA,MAAAA,EAAYJ,C;;;;;UAOLK,C,KAAAA,CAAAA,IAAAA,G;WCvBPC,IAAAA,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,EAAAA,MAAAA,GAAAA,CAAAA,GAAAA,M;;;;;;+CAmCaC,W,IAAAA,CAAAA,CAAAA,WAAAA,KAAAA,M,EAAAA;eACHC,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,KAAiBX,IAAAA,CAAAA,MAAAA,GAAuBY,QAAvBZ,CAAuBY,EAAvBZ,EAAuBY,KAAvBZ,CAAuBY,CAAvBZ,C,EAAuBY,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,C,EAAAA,eAAAA,CAAAA,GAAAA,I;;;;;;;;;;;;;;;WCxDlDI,C,EAAAA;;;;;;;;;;;;;;;;;;;;;;SCUOC,C,CAAAA,C,EAAAA;;YAUSC,CAAAA,CAAAA,IAAAA,EAAAA,CAAAA,CAAAA,CAAAA,CAAAA,CAAAA,KAAJ,C;;;;;mBASJC,CAAAA,CAAAA,IAAAA,EAAcC,CAAAA,CAAUC,CAAVD,CAAdD,CAAAA,KAAwBE,C,EAAVD,CAAAA,GAAiCrB,CAAAA,CAAAA,GAAAA,CAAAA,CAAAA,KAAAA,C;;;;;;;;;;;;;;;;;;;ACqBnDyB,SAAAA,CAAAA,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,CAAAA,EAAAA;SAMMC;gBAAAA;gBAAAA;iBAOJC,O,CAAAA,CAAAA,CAAAA,M,IAAAA,IAAAA,CAAAA,CAtDiCV;AAyDKW,MAAAA,aAAAA,EAA1CzB,CAAAA,CAAAA,MAzDqCc;gBA6DhCY;AA7DgCZ,KAsDjCU,C,SAPID;;AAAAA,G;;;WDPAF,C,EAAAA,C,EAAAA,C,EAAAA;;;;iBAUM;AAZdD,MAAAA,YAAAA,EAAAA,CAYc;;AAAA,K;;;;;;cFeFT,MAAAA,CAAAA,MAAAA,IAAAA,UAAAA,CAAAA,EAAAA;;;gBAGFE,CAAAA,GAAAA,SAAAA,CADLD,M,EAAAA,CAAAA,E,EAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;SFnEMd,K,QAAAA,6B;;;;;;;;;;;;;;;;yCALHD,C,CAAAA,C,EAAAA;;;;;;;;;;SMFH8B,Y,GAAc1B,C;;;;QLNVD,CAAAA,CAAAA,SAAAA,GAAAA,C;;;;;;;IGkBQ,IAAA,GAAA,E","sourcesContent":["import { GraphQLError } from 'graphql';\n\nconst generateErrorMessage = (\n  networkErr?: Error,\n  graphQlErrs?: GraphQLError[]\n) => {\n  let error = '';\n  if (networkErr !== undefined) {\n    return (error = `[Network] ${networkErr.message}`);\n  }\n\n  if (graphQlErrs !== undefined) {\n    graphQlErrs.forEach(err => {\n      error += `[GraphQL] ${err.message}\\n`;\n    });\n  }\n\n  return error.trim();\n};\n\nconst rehydrateGraphQlError = (error: any): GraphQLError => {\n  if (typeof error === 'string') {\n    return new GraphQLError(error);\n  } else if (typeof error === 'object' && error.message) {\n    return new GraphQLError(\n      error.message,\n      error.nodes,\n      error.source,\n      error.positions,\n      error.path,\n      error,\n      error.extensions || {}\n    );\n  } else {\n    return error as any;\n  }\n};\n\n/** An error which can consist of GraphQL errors and Network errors. */\nexport class CombinedError extends Error {\n  public name: string;\n  public message: string;\n  public graphQLErrors: GraphQLError[];\n  public networkError?: Error;\n  public response?: any;\n\n  constructor({\n    networkError,\n    graphQLErrors,\n    response,\n  }: {\n    networkError?: Error;\n    graphQLErrors?: Array<string | Partial<GraphQLError> | Error>;\n    response?: any;\n  }) {\n    const normalizedGraphQLErrors = (graphQLErrors || []).map(\n      rehydrateGraphQlError\n    );\n    const message = generateErrorMessage(networkError, normalizedGraphQLErrors);\n\n    super(message);\n\n    this.name = 'CombinedError';\n    this.message = message;\n    this.graphQLErrors = normalizedGraphQLErrors;\n    this.networkError = networkError;\n    this.response = response;\n  }\n\n  toString() {\n    return this.message;\n  }\n}\n","const seen = new Set();\nconst cache = new WeakMap();\n\nconst stringify = (x: any): string => {\n  if (x === null || seen.has(x)) {\n    return 'null';\n  } else if (typeof x !== 'object') {\n    return JSON.stringify(x) || '';\n  } else if (x.toJSON) {\n    return stringify(x.toJSON());\n  } else if (Array.isArray(x)) {\n    let out = '[';\n    for (let i = 0, l = x.length; i < l; i++) {\n      if (i > 0) out += ',';\n      const value = stringify(x[i]);\n      out += value.length > 0 ? value : 'null';\n    }\n\n    out += ']';\n    return out;\n  }\n\n  const keys = Object.keys(x).sort();\n  if (!keys.length && x.constructor && x.constructor !== Object) {\n    const key = cache.get(x) || Math.random().toString(36).slice(2);\n    cache.set(x, key);\n    return `{\"__key\":\"${key}\"}`;\n  }\n\n  seen.add(x);\n  let out = '{';\n  for (let i = 0, l = keys.length; i < l; i++) {\n    const key = keys[i];\n    const value = stringify(x[key]);\n    if (value) {\n      if (out.length > 1) out += ',';\n      out += stringify(key) + ':' + value;\n    }\n  }\n\n  seen.delete(x);\n  out += '}';\n  return out;\n};\n\nexport const stringifyVariables = (x: any): string => {\n  seen.clear();\n  return stringify(x);\n};\n","import { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  Location,\n  DefinitionNode,\n  DocumentNode,\n  Kind,\n  parse,\n  print,\n} from 'graphql';\n\nimport { hash, phash } from './hash';\nimport { stringifyVariables } from './stringifyVariables';\nimport { GraphQLRequest } from '../types';\n\ninterface WritableLocation {\n  loc: Location | undefined;\n}\n\nexport interface KeyedDocumentNode extends DocumentNode {\n  __key: number;\n}\n\nexport const stringifyDocument = (\n  node: string | DefinitionNode | DocumentNode\n): string => {\n  let str = (typeof node !== 'string'\n    ? (node.loc && node.loc.source.body) || print(node)\n    : node\n  )\n    .replace(/([\\s,]|#[^\\n\\r]+)+/g, ' ')\n    .trim();\n\n  if (typeof node !== 'string') {\n    if (node.loc) {\n      const operationName = 'definitions' in node && getOperationName(node);\n      if (operationName) str = `# ${operationName}\\n${str}`;\n    } else {\n      (node as WritableLocation).loc = {\n        start: 0,\n        end: str.length,\n        source: {\n          body: str,\n          name: 'gql',\n          locationOffset: { line: 1, column: 1 },\n        },\n      } as Location;\n    }\n  }\n\n  return str;\n};\n\nconst docs = new Map<number, KeyedDocumentNode>();\n\nexport const keyDocument = (q: string | DocumentNode): KeyedDocumentNode => {\n  let key: number;\n  let query: DocumentNode;\n  if (typeof q === 'string') {\n    key = hash(stringifyDocument(q));\n    query = docs.get(key) || parse(q, { noLocation: true });\n  } else {\n    key = (q as KeyedDocumentNode).__key || hash(stringifyDocument(q));\n    query = docs.get(key) || q;\n  }\n\n  // Add location information if it's missing\n  if (!query.loc) stringifyDocument(query);\n\n  (query as KeyedDocumentNode).__key = key;\n  docs.set(key, query as KeyedDocumentNode);\n  return query as KeyedDocumentNode;\n};\n\nexport const createRequest = <Data = any, Variables = object>(\n  q: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  vars?: Variables\n): GraphQLRequest<Data, Variables> => {\n  const query = keyDocument(q);\n  return {\n    key: vars\n      ? phash(query.__key, stringifyVariables(vars)) >>> 0\n      : query.__key,\n    query,\n    variables: vars || ({} as Variables),\n  };\n};\n\n/**\n * Finds the Name value from the OperationDefinition of a Document\n */\nexport const getOperationName = (query: DocumentNode): string | undefined => {\n  for (let i = 0, l = query.definitions.length; i < l; i++) {\n    const node = query.definitions[i];\n    if (node.kind === Kind.OPERATION_DEFINITION && node.name) {\n      return node.name.value;\n    }\n  }\n};\n","import { Operation, OperationResult } from '../types';\nimport { CombinedError } from './error';\n\nexport const makeResult = (\n  operation: Operation,\n  result: any,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: result.data,\n  error: Array.isArray(result.errors)\n    ? new CombinedError({\n        graphQLErrors: result.errors,\n        response,\n      })\n    : undefined,\n  extensions:\n    (typeof result.extensions === 'object' && result.extensions) || undefined,\n});\n\nexport const makeErrorResult = (\n  operation: Operation,\n  error: Error,\n  response?: any\n): OperationResult => ({\n  operation,\n  data: undefined,\n  error: new CombinedError({\n    networkError: error,\n    response,\n  }),\n  extensions: undefined,\n});\n","import { Operation, OperationResult } from '../types';\nimport { makeResult, makeErrorResult } from '../utils';\nimport { make } from 'wonka';\n\nconst executeFetch = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n): Promise<OperationResult> => {\n  const fetcher = operation.context.fetch;\n\n  let statusNotOk = false;\n  let response: Response;\n\n  return (fetcher || fetch)(url, fetchOptions)\n    .then((res: Response) => {\n      response = res;\n      statusNotOk =\n        res.status < 200 ||\n        res.status >= (fetchOptions.redirect === 'manual' ? 400 : 300);\n      return res.json();\n    })\n    .then((result: any) => {\n      if (!('data' in result) && !('errors' in result)) {\n        throw new Error('No Content');\n      }\n\n      return makeResult(operation, result, response);\n    })\n    .catch((error: Error) => {\n      if (error.name !== 'AbortError') {\n        return makeErrorResult(\n          operation,\n          statusNotOk ? new Error(response.statusText) : error,\n          response\n        );\n      }\n    }) as Promise<OperationResult>;\n};\n\nexport const makeFetchSource = (\n  operation: Operation,\n  url: string,\n  fetchOptions: RequestInit\n) => {\n  return make<OperationResult>(({ next, complete }) => {\n    const abortController =\n      typeof AbortController !== 'undefined' ? new AbortController() : null;\n\n    let ended = false;\n\n    Promise.resolve()\n      .then(() => {\n        if (ended) {\n          return;\n        } else if (abortController) {\n          fetchOptions.signal = abortController.signal;\n        }\n\n        return executeFetch(operation, url, fetchOptions);\n      })\n      .then((result: OperationResult | undefined) => {\n        if (!ended) {\n          ended = true;\n          if (result) next(result);\n          complete();\n        }\n      });\n\n    return () => {\n      ended = true;\n      if (abortController) {\n        abortController.abort();\n      }\n    };\n  });\n};\n","import { DocumentNode, print } from 'graphql';\n\nimport { getOperationName, stringifyVariables } from '../utils';\nimport { Operation } from '../types';\n\nexport interface FetchBody {\n  query?: string;\n  operationName: string | undefined;\n  variables: undefined | Record<string, any>;\n  extensions: undefined | Record<string, any>;\n}\n\nconst shouldUseGet = (operation: Operation): boolean => {\n  return operation.kind === 'query' && !!operation.context.preferGetMethod;\n};\n\nexport const makeFetchBody = (request: {\n  query: DocumentNode;\n  variables?: object;\n}): FetchBody => ({\n  query: print(request.query),\n  operationName: getOperationName(request.query),\n  variables: request.variables || undefined,\n  extensions: undefined,\n});\n\nexport const makeFetchURL = (\n  operation: Operation,\n  body?: FetchBody\n): string => {\n  const useGETMethod = shouldUseGet(operation);\n  const url = operation.context.url;\n  if (!useGETMethod || !body) return url;\n\n  const search: string[] = [];\n  if (body.operationName) {\n    search.push('operationName=' + encodeURIComponent(body.operationName));\n  }\n\n  if (body.query) {\n    search.push(\n      'query=' +\n        encodeURIComponent(\n          body.query.replace(/([\\s,]|#[^\\n\\r]+)+/g, ' ').trim()\n        )\n    );\n  }\n\n  if (body.variables) {\n    search.push(\n      'variables=' + encodeURIComponent(stringifyVariables(body.variables))\n    );\n  }\n\n  if (body.extensions) {\n    search.push(\n      'extensions=' + encodeURIComponent(stringifyVariables(body.extensions))\n    );\n  }\n\n  return `${url}?${search.join('&')}`;\n};\n\nexport const makeFetchOptions = (\n  operation: Operation,\n  body?: FetchBody\n): RequestInit => {\n  const useGETMethod = shouldUseGet(operation);\n\n  const extraOptions =\n    typeof operation.context.fetchOptions === 'function'\n      ? operation.context.fetchOptions()\n      : operation.context.fetchOptions || {};\n\n  return {\n    ...extraOptions,\n    body: !useGETMethod && body ? JSON.stringify(body) : undefined,\n    method: useGETMethod ? 'GET' : 'POST',\n    headers: useGETMethod\n      ? extraOptions.headers\n      : { 'content-type': 'application/json', ...extraOptions.headers },\n  };\n};\n","// When we have separate strings it's useful to run a progressive\n// version of djb2 where we pretend that we're still looping over\n// the same string\nexport const phash = (h: number, x: string): number => {\n  h = h | 0;\n  for (let i = 0, l = x.length | 0; i < l; i++) {\n    h = (h << 5) + h + x.charCodeAt(i);\n  }\n\n  return h;\n};\n\n// This is a djb2 hashing function\nexport const hash = (x: string): number => phash(5381 | 0, x) >>> 0;\n"]},"metadata":{},"sourceType":"module"}