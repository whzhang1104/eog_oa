{"ast":null,"code":"function n(a, b) {\n  if (Array.isArray(a)) {\n    for (var c = 0; c < a.length; c++) {\n      n(a[c], b);\n    }\n  } else if (\"object\" == typeof a && null !== a) {\n    for (c in a) {\n      \"__typename\" === c && \"string\" == typeof a[c] ? b[a[c]] = 0 : n(a[c], b);\n    }\n  }\n\n  return b;\n}\n\nfunction p(a) {\n  return a.kind === Kind.FIELD && \"__typename\" === a.name.value && !a.alias;\n}\n\nfunction r(a) {\n  if (a.selectionSet && !a.selectionSet.selections.some(p)) {\n    return _extends({}, a, {\n      selectionSet: _extends({}, a.selectionSet, {\n        selections: a.selectionSet.selections.concat([{\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: \"__typename\"\n          }\n        }])\n      })\n    });\n  }\n}\n\nfunction u(a) {\n  a = keyDocument(a);\n  var b = t.get(a.__key);\n  b || ((b = visit(a, {\n    Field: r,\n    InlineFragment: r\n  })).__key = a.__key, t.set(a.__key, b));\n  return b;\n}\n\nfunction v(a) {\n  return a && \"object\" == typeof a ? Object.keys(a).reduce(function (b, c) {\n    var d = a[c];\n    \"__typename\" === c ? Object.defineProperty(b, \"__typename\", {\n      enumerable: !1,\n      value: d\n    }) : Array.isArray(d) ? b[c] = d.map(v) : b[c] = d && \"object\" == typeof d && \"__typename\" in d ? v(d) : d;\n    return b;\n  }, {}) : a;\n}\n\nfunction w(a) {\n  a.toPromise = function () {\n    return toPromise(take(1)(a));\n  };\n\n  return a;\n}\n\nfunction z(a, b, c) {\n  c || (c = b.context);\n  return {\n    key: b.key,\n    query: b.query,\n    variables: b.variables,\n    kind: a,\n    context: c,\n\n    get operationName() {\n      if (\"production\" !== process.env.NODE_ENV) {\n        var a = y_operationName,\n            c = a.key;\n        a = a.message;\n        x[c] || (console.warn(\"[WARNING: Deprecated] \" + a), x[c] = !0);\n      }\n\n      return this.kind;\n    }\n\n  };\n}\n\nfunction A(a, b) {\n  return z(a.kind, a, _extends({}, a.context, {\n    meta: _extends({}, a.context.meta, b)\n  }));\n}\n\nfunction B() {}\n\nfunction C(a, b, c) {\n  var d, e, f;\n\n  for (d = 0; d < c.length; d++) {\n    if (c[d].kind === Kind.FRAGMENT_DEFINITION) {\n      e = c[d].name.value, f = stringifyDocument(c[d]);\n      a.has(e) ? \"production\" !== process.env.NODE_ENV && a.get(e) !== f && console.warn(\"[WARNING: Duplicate Fragment] A fragment with name `\" + e + \"` already exists in this document.\\nWhile fragment names may not be unique across your source, each name must be unique per document.\") : (a.set(e, f), b.push(c[d]));\n    } else {\n      b.push(c[d]);\n    }\n  }\n}\n\nfunction D(a) {\n  return \"subscription\" !== (a = a.kind) && \"query\" !== a;\n}\n\nfunction E(a) {\n  return a.path || a.extensions ? {\n    message: a.message,\n    path: a.path,\n    extensions: a.extensions\n  } : a.message;\n}\n\nfunction F(a) {\n  return \"mutation\" !== (a = a.kind) && \"query\" !== a;\n}\n\nfunction G(a) {\n  var b = z(a.kind, a);\n  b.query = u(a.query);\n  return b;\n}\n\nfunction H(a) {\n  return \"query\" !== a.kind || \"cache-only\" !== a.context.requestPolicy;\n}\n\nfunction I(a) {\n  return A(a, {\n    cacheOutcome: \"miss\"\n  });\n}\n\nfunction J(a) {\n  return F(a);\n}\n\nfunction K(a) {\n  function b(a) {\n    var b = a.context.requestPolicy;\n    return \"query\" === a.kind && \"network-only\" !== b && (\"cache-only\" === b || k.has(a.key));\n  }\n\n  function c(a) {\n    var c = k.get(a.key);\n    \"production\" !== process.env.NODE_ENV && q(_extends({}, {\n      operation: a\n    }, c ? {\n      type: \"cacheHit\",\n      message: \"The result was successfully retried from the cache\"\n    } : {\n      type: \"cacheMiss\",\n      message: \"The result could not be retrieved from the cache\"\n    }));\n    c = _extends({}, c, {\n      operation: A(a, {\n        cacheOutcome: c ? \"hit\" : \"miss\"\n      })\n    });\n    \"cache-and-network\" === a.context.requestPolicy && (c.stale = !0, L(m, a));\n    return c;\n  }\n\n  function d(a) {\n    return !F(a) && b(a);\n  }\n\n  function e(a) {\n    function c(a) {\n      l.add(a);\n    }\n\n    var e,\n        l,\n        g,\n        d = a.operation;\n\n    if (d) {\n      e = Object.keys(n(a.data, {})).concat(d.context.additionalTypenames || []);\n\n      if (\"mutation\" === a.operation.kind) {\n        l = new Set();\n        \"production\" !== process.env.NODE_ENV && q({\n          type: \"cacheInvalidation\",\n          message: \"The following typenames have been invalidated: \" + e,\n          operation: d,\n          data: {\n            typenames: e,\n            response: a\n          },\n          source: \"cacheExchange\"\n        });\n\n        for (a = 0; a < e.length; a++) {\n          (g = h[g = e[a]] || (h[g] = new Set())).forEach(c);\n          g.clear();\n        }\n\n        l.forEach(function b(a) {\n          k.has(a) && (d = k.get(a).operation, k.delete(a), L(m, d));\n        });\n      } else if (\"query\" === d.kind && a.data) {\n        for (k.set(d.key, a), a = 0; a < e.length; a++) {\n          (h[g = e[a]] || (h[g] = new Set())).add(d.key);\n        }\n      }\n    }\n  }\n\n  function f(a) {\n    return !F(a) && !b(a);\n  }\n\n  var g = a.forward,\n      m = a.client,\n      q = a.dispatchDebug,\n      k = new Map(),\n      h = Object.create(null);\n  return function (a) {\n    var b = share(a);\n    a = map(c)(filter(d)(b));\n    b = tap(e)(g(filter(H)(map(I)(merge([map(G)(filter(f)(b)), filter(J)(b)])))));\n    return merge([a, b]);\n  };\n}\n\nfunction L(a, b) {\n  return a.reexecuteOperation(z(b.kind, b, _extends({}, b.context, {\n    requestPolicy: \"network-only\"\n  })));\n}\n\nfunction M(a) {\n  return console.log(\"[Exchange debug]: Completed operation: \", a);\n}\n\nfunction N(a) {\n  return console.log(\"[Exchange debug]: Incoming operation: \", a);\n}\n\nfunction O(a) {\n  function b(a) {\n    f.delete(a.operation.key);\n  }\n\n  function c(a) {\n    var c = a.key,\n        b = a.kind;\n\n    if (\"teardown\" === b) {\n      return f.delete(c), !0;\n    }\n\n    if (\"query\" !== b && \"subscription\" !== b) {\n      return !0;\n    }\n\n    b = f.has(c);\n    f.add(c);\n    b && \"production\" !== process.env.NODE_ENV && e({\n      type: \"dedup\",\n      message: \"An operation has been deduped.\",\n      operation: a,\n      source: \"dedupExchange\"\n    });\n    return !b;\n  }\n\n  var d = a.forward,\n      e = a.dispatchDebug,\n      f = new Set();\n  return function (a) {\n    a = filter(c)(a);\n    return tap(b)(d(a));\n  };\n}\n\nfunction P(a) {\n  return \"query\" === a.kind || \"mutation\" === a.kind;\n}\n\nfunction Q(a) {\n  return \"query\" !== a.kind && \"mutation\" !== a.kind;\n}\n\nfunction R(a) {\n  var b = a.forward,\n      c = a.dispatchDebug;\n  return function (a) {\n    var f,\n        d = share(a);\n    a = mergeMap(function (a) {\n      var b = a.key,\n          e = filter(function (a) {\n        return \"teardown\" === a.kind && a.key === b;\n      })(d),\n          f = makeFetchBody(a),\n          h = makeFetchURL(a, f),\n          l = makeFetchOptions(a, f);\n      \"production\" !== process.env.NODE_ENV && c({\n        type: \"fetchRequest\",\n        message: \"A fetch request is being executed.\",\n        operation: a,\n        data: {\n          url: h,\n          fetchOptions: l\n        },\n        source: \"fetchExchange\"\n      });\n      return onPush(function (b) {\n        var d = b.data ? void 0 : b.error;\n        \"production\" !== process.env.NODE_ENV && c({\n          type: d ? \"fetchError\" : \"fetchSuccess\",\n          message: \"A \" + (d ? \"failed\" : \"successful\") + \" fetch response has been returned.\",\n          operation: a,\n          data: {\n            url: h,\n            fetchOptions: l,\n            value: d || b\n          },\n          source: \"fetchExchange\"\n        });\n      })(takeUntil(e)(makeFetchSource(a, h, l)));\n    })(filter(P)(d));\n    f = b(filter(Q)(d));\n    return merge([a, f]);\n  };\n}\n\nfunction S() {\n  return !1;\n}\n\nfunction T(a) {\n  function b(a) {\n    if (\"teardown\" !== a.kind && \"production\" !== process.env.NODE_ENV) {\n      var b = 'No exchange has handled operations of kind \"' + a.kind + \"\\\". Check whether you've added an exchange responsible for these operations.\";\n      \"production\" !== process.env.NODE_ENV && c({\n        type: \"fallbackCatch\",\n        message: b,\n        operation: a,\n        source: \"fallbackExchange\"\n      });\n      console.warn(b);\n    }\n  }\n\n  var c = a.dispatchDebug;\n  return function (a) {\n    return filter(S)(tap(b)(a));\n  };\n}\n\nfunction V(a) {\n  return function (b) {\n    var c = b.client,\n        d = b.dispatchDebug;\n    return a.reduceRight(function (a, b) {\n      return b({\n        client: c,\n        forward: a,\n        dispatchDebug: function dispatchDebug(a) {\n          \"production\" !== process.env.NODE_ENV && d(_extends({}, {\n            timestamp: Date.now(),\n            source: b.name\n          }, a));\n        }\n      });\n    }, b.forward);\n  };\n}\n\nfunction X(a) {\n  var d,\n      e,\n      f,\n      g,\n      m,\n      c = this;\n  this.activeOperations = Object.create(null);\n  this.queue = [];\n\n  this.createOperationContext = function (a) {\n    a || (a = {});\n    return _extends({}, {\n      url: c.url,\n      fetchOptions: c.fetchOptions,\n      fetch: c.fetch,\n      preferGetMethod: c.preferGetMethod\n    }, a, {\n      suspense: a.suspense || !1 !== a.suspense && c.suspense,\n      requestPolicy: a.requestPolicy || c.requestPolicy\n    });\n  };\n\n  this.createRequestOperation = function (a, b, d) {\n    return z(a, b, c.createOperationContext(d));\n  };\n\n  this.executeQuery = function (a, b) {\n    a = c.createRequestOperation(\"query\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  this.executeSubscription = function (a, b) {\n    a = c.createRequestOperation(\"subscription\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  this.executeMutation = function (a, b) {\n    a = c.createRequestOperation(\"mutation\", a, b);\n    return c.executeRequestOperation(a);\n  };\n\n  if (\"production\" !== process.env.NODE_ENV && !a.url) {\n    throw Error(\"You are creating an urql-client without a url.\");\n  }\n\n  d = B;\n\n  if (\"production\" !== process.env.NODE_ENV) {\n    e = (d = makeSubject()).next, f = d.source;\n\n    this.subscribeToDebugTarget = function b(a) {\n      return subscribe(a)(f);\n    };\n\n    d = e;\n  }\n\n  this.url = a.url;\n  this.fetchOptions = a.fetchOptions;\n  this.fetch = a.fetch;\n  this.suspense = !!a.suspense;\n  this.requestPolicy = a.requestPolicy || \"cache-first\";\n  this.preferGetMethod = !!a.preferGetMethod;\n  this.maskTypename = !!a.maskTypename;\n  e = makeSubject();\n  g = e.next;\n  this.operations$ = e.source;\n  m = !1;\n\n  this.dispatchOperation = function (a) {\n    m = !0;\n\n    for (a && g(a); a = c.queue.shift();) {\n      g(a);\n    }\n\n    m = !1;\n  };\n\n  this.reexecuteOperation = function (a) {\n    if (\"mutation\" === a.kind || 0 < (c.activeOperations[a.key] || 0)) {\n      c.queue.push(a), m || Promise.resolve().then(c.dispatchOperation);\n    }\n  };\n\n  a = V(void 0 !== a.exchanges ? a.exchanges : W);\n  this.results$ = share(a({\n    client: this,\n    dispatchDebug: d,\n    forward: T({\n      dispatchDebug: d\n    })\n  })(this.operations$));\n  publish(this.results$);\n}\n\nfunction Y(a) {\n  a.data = v(a.data);\n  return a;\n}\n\nfunction createClient(a) {\n  return new X(a);\n}\n\nfunction debugExchange(a) {\n  var d = a.forward;\n  return \"production\" === process.env.NODE_ENV ? function b(a) {\n    return d(a);\n  } : function c(a) {\n    return tap(M)(d(tap(N)(a)));\n  };\n}\n\nfunction errorExchange(a) {\n  function b(a) {\n    var b = a.error;\n    a = a.operation;\n    b && c(b, a);\n  }\n\n  var c = a.onError;\n  return function (a) {\n    var c = a.forward;\n    return function (a) {\n      return tap(b)(c(a));\n    };\n  };\n}\n\nfunction gql() {\n  var a, b, c, d, e, f, g;\n\n  for (a = arguments, b = new Map(), c = [], d = [], e = Array.isArray(arguments[0]) ? arguments[0][0] : arguments[0] || \"\", f = 1; f < arguments.length; f++) {\n    (g = a[f]) && g.definitions ? d.push.apply(d, g.definitions) : e += g;\n    e += a[0][f];\n  }\n\n  C(b, c, keyDocument(e).definitions);\n  C(b, c, d);\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions: c\n  });\n}\n\nfunction ssrExchange(a) {\n  function b(b) {\n    var c = b.client,\n        e = b.forward;\n    return function (b) {\n      var l = a && \"boolean\" == typeof a.isClient ? !!a.isClient : !c.suspense,\n          h = share(b);\n      b = e(filter(f)(h));\n      h = map(g)(filter(m)(h));\n      l ? h = tap(d)(h) : b = tap(q)(b);\n      return merge([b, h]);\n    };\n  }\n\n  function c(a) {\n    return !D(a) && void 0 !== k[a.key];\n  }\n\n  function d(a) {\n    h.push(a.operation.key);\n    1 === h.length && Promise.resolve().then(e);\n  }\n\n  function e() {\n    for (var a; a = h.shift();) {\n      delete k[a];\n    }\n  }\n\n  function f(a) {\n    return !c(a);\n  }\n\n  function g(a) {\n    var b = k[a.key],\n        c = b.error;\n    return {\n      operation: a,\n      data: (b = b.data) ? JSON.parse(b) : void 0,\n      extensions: void 0,\n      error: c ? new CombinedError({\n        networkError: c.networkError ? Error(c.networkError) : void 0,\n        graphQLErrors: c.graphQLErrors && c.graphQLErrors.length ? c.graphQLErrors : void 0\n      }) : void 0\n    };\n  }\n\n  function m(a) {\n    return c(a);\n  }\n\n  function q(a) {\n    var c,\n        d,\n        b = a.operation;\n\n    if (!D(b)) {\n      c = a.data;\n      a = a.error;\n      d = {};\n      void 0 !== c && (d.data = JSON.stringify(c));\n      a && (d.error = {\n        graphQLErrors: a.graphQLErrors.map(E)\n      }, a.networkError && (d.error.networkError = \"\" + a.networkError));\n      k[b.key] = d;\n    }\n  }\n\n  var k = {},\n      h = [];\n\n  b.restoreData = function (a) {\n    return _extends(k, a);\n  };\n\n  b.extractData = function () {\n    return _extends({}, k);\n  };\n\n  a && a.initialState && b.restoreData(a.initialState);\n  return b;\n}\n\nfunction subscriptionExchange(a) {\n  function b(a) {\n    return \"subscription\" === (a = a.kind) || !!d && (\"query\" === a || \"mutation\" === a);\n  }\n\n  var c = a.forwardSubscription,\n      d = a.enableAllOperations;\n  return function (a) {\n    function d(a) {\n      var b = c({\n        key: a.key.toString(36),\n        query: print(a.query),\n        variables: a.variables,\n        context: _extends({}, a.context)\n      });\n      return make(function (c) {\n        function d(b) {\n          return h(makeResult(a, b));\n        }\n\n        function e(b) {\n          return h(makeErrorResult(a, b));\n        }\n\n        function f() {\n          k || (k = !0, \"subscription\" === a.kind && m.reexecuteOperation(z(\"teardown\", a, a.context)), g());\n        }\n\n        var l,\n            h = c.next,\n            g = c.complete,\n            k = !1;\n        Promise.resolve().then(function () {\n          k || (l = b.subscribe({\n            next: d,\n            error: e,\n            complete: f\n          }));\n        });\n        return function () {\n          k = !0;\n          l && l.unsubscribe();\n        };\n      });\n    }\n\n    function e(a) {\n      return !k(a);\n    }\n\n    var m = a.client,\n        q = a.forward,\n        k = b;\n    return function (a) {\n      var c,\n          b = share(a);\n      a = mergeMap(function (a) {\n        var c = a.key,\n            e = filter(function (a) {\n          return \"teardown\" === a.kind && a.key === c;\n        })(b);\n        return takeUntil(e)(d(a));\n      })(filter(k)(b));\n      c = q(filter(e)(b));\n      return merge([a, c]);\n    };\n  };\n}\n\nvar t, x, y_operationName, U, W;\nimport { toPromise, take, share, filter, map, tap, merge, mergeMap, takeUntil, make, onPush, makeSubject, publish, onStart, onEnd, switchMap, fromValue, interval, subscribe } from \"wonka\";\nimport { k as keyDocument, _ as _extends, s as stringifyDocument, C as CombinedError, m as makeResult, a as makeErrorResult, b as makeFetchBody, c as makeFetchURL, d as makeFetchOptions, e as makeFetchSource, f as createRequest } from \"./2c01d8b2.mjs\";\nimport { visit } from \"graphql/language/visitor.mjs\";\nimport { Kind } from \"graphql/language/kinds.mjs\";\nimport { print } from \"graphql/language/printer.mjs\";\nexport { C as CombinedError, f as createRequest, h as getOperationName, a as makeErrorResult, m as makeResult, g as stringifyVariables } from \"./2c01d8b2.mjs\";\nt = new Map();\nx = {}, y_operationName = {\n  key: \"Operation.operationName\",\n  message: 'The \"Operation.operationName\" property has been deprecated and will be removed in a future release of urql. Use \"Operation.kind\" instead.'\n};\nU = T({\n  dispatchDebug: B\n});\nW = [O, K, R];\n\nX.prototype.onOperationStart = function (a) {\n  var b = a.key;\n  this.activeOperations[b] = (this.activeOperations[b] || 0) + 1;\n  this.dispatchOperation(a);\n};\n\nX.prototype.onOperationEnd = function (a) {\n  var b = a.key,\n      c = this.activeOperations[b] || 0;\n\n  if (0 >= (this.activeOperations[b] = 0 >= c ? 0 : c - 1)) {\n    for (b = this.queue.length - 1; 0 <= b; b--) {\n      this.queue[b].key === a.key && this.queue.splice(b, 1);\n    }\n\n    this.dispatchOperation(z(\"teardown\", a, a.context));\n  }\n};\n\nX.prototype.executeRequestOperation = function (a) {\n  var f,\n      g,\n      d = this,\n      e = filter(function (b) {\n    return b.operation.key === a.key;\n  })(this.results$);\n  this.maskTypename && (e = map(Y)(e));\n\n  if (\"mutation\" === a.kind) {\n    return take(1)(onStart(function b() {\n      return d.dispatchOperation(a);\n    })(e));\n  }\n\n  f = filter(function (b) {\n    return \"teardown\" === b.kind && b.key === a.key;\n  })(this.operations$), g = onEnd(function () {\n    d.onOperationEnd(a);\n  })(onStart(function () {\n    d.onOperationStart(a);\n  })(takeUntil(f)(e)));\n  return \"query\" === a.kind && a.context.pollInterval ? switchMap(function c() {\n    return g;\n  })(merge([fromValue(0), interval(a.context.pollInterval)])) : g;\n};\n\nX.prototype.query = function (a, b, c) {\n  c && \"boolean\" == typeof c.suspense || (c = _extends({}, c, {\n    suspense: !1\n  }));\n  return w(this.executeQuery(createRequest(a, b), c));\n};\n\nX.prototype.readQuery = function (a, b, c) {\n  var d = null;\n  subscribe(function (a) {\n    d = a;\n  })(this.executeQuery(createRequest(a, b), c)).unsubscribe();\n  return d;\n};\n\nX.prototype.subscription = function (a, b, c) {\n  return this.executeSubscription(createRequest(a, b), c);\n};\n\nX.prototype.mutation = function (a, b, c) {\n  return w(this.executeMutation(createRequest(a, b), c));\n};\n\nexport { X as Client, K as cacheExchange, V as composeExchanges, createClient, debugExchange, O as dedupExchange, W as defaultExchanges, errorExchange, U as fallbackExchangeIO, R as fetchExchange, u as formatDocument, gql, z as makeOperation, v as maskTypename, ssrExchange, subscriptionExchange };","map":{"version":3,"sources":["../src/utils/typenames.ts","../src/utils/operation.ts","../src/gql.ts","../src/exchanges/cache.ts","../src/exchanges/debug.ts","../src/exchanges/dedup.ts","../src/exchanges/fetch.ts","../src/exchanges/fallback.ts","../src/client.ts","../src/exchanges/ssr.ts","../src/exchanges/subscription.ts","../src/utils/deprecation.ts"],"names":["types","let","obj","const","node","result","formattedDocs","DEPRECATED","context","meta","fragmentNames","i","arguments","formattedOperation","share","map","shouldSkip","addMetadata","operation","operations","key","resultCache","a","response","forward","tap","console","inFlightKeys","afterOperationResult","body","makeFetchSource","teardown$","onPush","ops$","message","opts","isOperationBatchActive","this","composeExchanges","makeOperation","results$","res","onStart","c","JSON","error","invalidateQueue","Promise","undefined","isClient","forwardedOps$","cachedOps$","isCached","op","data","sharedOps$","mergeMap","filter","issuedWarnings"],"mappings":"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","sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  InlineFragmentNode,\n  SelectionNode,\n  Kind,\n  visit,\n} from 'graphql';\n\nimport { KeyedDocumentNode, keyDocument } from './request';\n\ninterface EntityLike {\n  [key: string]: EntityLike | EntityLike[] | any;\n  __typename: string | null | void;\n}\n\nconst collectTypes = (\n  obj: EntityLike | EntityLike[],\n  types: { [typename: string]: unknown }\n) => {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) collectTypes(obj[i], types);\n  } else if (typeof obj === 'object' && obj !== null) {\n    for (const key in obj) {\n      if (key === '__typename' && typeof obj[key] === 'string') {\n        types[obj[key] as string] = 0;\n      } else {\n        collectTypes(obj[key], types);\n      }\n    }\n  }\n\n  return types;\n};\n\nexport const collectTypesFromResponse = (response: object) =>\n  Object.keys(collectTypes(response as EntityLike, {}));\n\nconst formatNode = (node: FieldNode | InlineFragmentNode) => {\n  if (\n    node.selectionSet &&\n    !node.selectionSet.selections.some(\n      node =>\n        node.kind === Kind.FIELD &&\n        node.name.value === '__typename' &&\n        !node.alias\n    )\n  ) {\n    return {\n      ...node,\n      selectionSet: {\n        ...node.selectionSet,\n        selections: [\n          ...(node.selectionSet.selections as SelectionNode[]),\n          {\n            kind: Kind.FIELD,\n            name: {\n              kind: Kind.NAME,\n              value: '__typename',\n            },\n          },\n        ],\n      },\n    };\n  }\n};\n\nconst formattedDocs = new Map<number, KeyedDocumentNode>();\n\nexport const formatDocument = <T extends DocumentNode>(node: T): T => {\n  const query = keyDocument(node);\n\n  let result = formattedDocs.get(query.__key);\n  if (!result) {\n    result = visit(query, {\n      Field: formatNode,\n      InlineFragment: formatNode,\n    }) as KeyedDocumentNode;\n    // Ensure that the hash of the resulting document won't suddenly change\n    result.__key = query.__key;\n    formattedDocs.set(query.__key, result);\n  }\n\n  return (result as unknown) as T;\n};\n","import {\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationType,\n} from '../types';\nimport { Warning, deprecationWarning } from './deprecation';\n\n// TODO: Remove when the deprecated `operationName` property is removed\nconst DEPRECATED: Record<string, Warning> = {\n  operationName: {\n    key: 'Operation.operationName',\n    message:\n      'The \"Operation.operationName\" property has been deprecated and will be removed in a future release of urql. Use \"Operation.kind\" instead.',\n  },\n};\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: GraphQLRequest<Data, Variables>,\n  context: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation<Data = any, Variables = object>(\n  kind: OperationType,\n  request: Operation<Data, Variables>,\n  context?: OperationContext\n): Operation<Data, Variables>;\n\nfunction makeOperation(kind, request, context) {\n  if (!context) context = request.context;\n\n  return {\n    key: request.key,\n    query: request.query,\n    variables: request.variables,\n    kind,\n    context,\n\n    get operationName(): OperationType {\n      deprecationWarning(DEPRECATED.operationName);\n\n      return this.kind;\n    },\n  };\n}\n\nexport { makeOperation };\n\n/** Spreads the provided metadata to the source operation's meta property in context.  */\nexport const addMetadata = (\n  operation: Operation,\n  meta: OperationContext['meta']\n) => {\n  return makeOperation(operation.kind, operation, {\n    ...operation.context,\n    meta: {\n      ...operation.context.meta,\n      ...meta,\n    },\n  });\n};\n","/* eslint-disable prefer-rest-params */\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\n\nimport {\n  DocumentNode,\n  DefinitionNode,\n  FragmentDefinitionNode,\n  Kind,\n} from 'graphql';\n\nimport { keyDocument, stringifyDocument } from './utils';\n\nconst applyDefinitions = (\n  fragmentNames: Map<string, string>,\n  target: DefinitionNode[],\n  source: Array<DefinitionNode> | ReadonlyArray<DefinitionNode>\n) => {\n  for (let i = 0; i < source.length; i++) {\n    if (source[i].kind === Kind.FRAGMENT_DEFINITION) {\n      const name = (source[i] as FragmentDefinitionNode).name.value;\n      const value = stringifyDocument(source[i]);\n      // Fragments will be deduplicated according to this Map\n      if (!fragmentNames.has(name)) {\n        fragmentNames.set(name, value);\n        target.push(source[i]);\n      } else if (\n        process.env.NODE_ENV !== 'production' &&\n        fragmentNames.get(name) !== value\n      ) {\n        // Fragments with the same names is expected to have the same contents\n        console.warn(\n          '[WARNING: Duplicate Fragment] A fragment with name `' +\n            name +\n            '` already exists in this document.\\n' +\n            'While fragment names may not be unique across your source, each name must be unique per document.'\n        );\n      }\n    } else {\n      target.push(source[i]);\n    }\n  }\n};\n\nfunction gql<Data = any, Variables = object>(\n  strings: TemplateStringsArray,\n  ...interpolations: Array<TypedDocumentNode | DocumentNode | string>\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql<Data = any, Variables = object>(\n  string: string\n): TypedDocumentNode<Data, Variables>;\n\nfunction gql(/* arguments */) {\n  const fragmentNames = new Map<string, string>();\n  const definitions: DefinitionNode[] = [];\n  const interpolations: DefinitionNode[] = [];\n\n  // Apply the entire tagged template body's definitions\n  let body: string = Array.isArray(arguments[0])\n    ? arguments[0][0]\n    : arguments[0] || '';\n  for (let i = 1; i < arguments.length; i++) {\n    const value = arguments[i];\n    if (value && value.definitions) {\n      interpolations.push(...value.definitions);\n    } else {\n      body += value;\n    }\n\n    body += arguments[0][i];\n  }\n\n  // Apply the tag's body definitions\n  applyDefinitions(fragmentNames, definitions, keyDocument(body).definitions);\n  // Copy over each interpolated document's definitions\n  applyDefinitions(fragmentNames, definitions, interpolations);\n\n  return keyDocument({\n    kind: Kind.DOCUMENT,\n    definitions,\n  });\n}\n\nexport { gql };\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, map, merge, pipe, share, tap } from 'wonka';\n\nimport { Client } from '../client';\nimport { Exchange, Operation, OperationResult } from '../types';\n\nimport {\n  makeOperation,\n  addMetadata,\n  collectTypesFromResponse,\n  formatDocument,\n} from '../utils';\n\ntype ResultCache = Map<number, OperationResult>;\n\ninterface OperationCache {\n  [key: string]: Set<number>;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'mutation' && kind !== 'query';\n\nexport const cacheExchange: Exchange = ({ forward, client, dispatchDebug }) => {\n  const resultCache = new Map() as ResultCache;\n  const operationCache = Object.create(null) as OperationCache;\n\n  // Adds unique typenames to query (for invalidating cache entries)\n  const mapTypeNames = (operation: Operation): Operation => {\n    const formattedOperation = makeOperation(operation.kind, operation);\n    formattedOperation.query = formatDocument(operation.query);\n    return formattedOperation;\n  };\n\n  const isOperationCached = (operation: Operation) => {\n    const {\n      key,\n      kind,\n      context: { requestPolicy },\n    } = operation;\n    return (\n      kind === 'query' &&\n      requestPolicy !== 'network-only' &&\n      (requestPolicy === 'cache-only' || resultCache.has(key))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n\n    const cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => !shouldSkip(op) && isOperationCached(op)),\n      map(operation => {\n        const cachedResult = resultCache.get(operation.key);\n\n        dispatchDebug({\n          operation,\n          ...(cachedResult\n            ? {\n                type: 'cacheHit',\n                message: 'The result was successfully retried from the cache',\n              }\n            : {\n                type: 'cacheMiss',\n                message: 'The result could not be retrieved from the cache',\n              }),\n        });\n\n        const result: OperationResult = {\n          ...cachedResult,\n          operation: addMetadata(operation, {\n            cacheOutcome: cachedResult ? 'hit' : 'miss',\n          }),\n        };\n\n        if (operation.context.requestPolicy === 'cache-and-network') {\n          result.stale = true;\n          reexecuteOperation(client, operation);\n        }\n\n        return result;\n      })\n    );\n\n    const forwardedOps$ = pipe(\n      merge([\n        pipe(\n          sharedOps$,\n          filter(op => !shouldSkip(op) && !isOperationCached(op)),\n          map(mapTypeNames)\n        ),\n        pipe(\n          sharedOps$,\n          filter(op => shouldSkip(op))\n        ),\n      ]),\n      map(op => addMetadata(op, { cacheOutcome: 'miss' })),\n      filter(\n        op => op.kind !== 'query' || op.context.requestPolicy !== 'cache-only'\n      ),\n      forward,\n      tap(response => {\n        let { operation } = response;\n        if (!operation) return;\n\n        const typenames = collectTypesFromResponse(response.data).concat(\n          operation.context.additionalTypenames || []\n        );\n\n        // Invalidates the cache given a mutation's response\n        if (response.operation.kind === 'mutation') {\n          const pendingOperations = new Set<number>();\n\n          dispatchDebug({\n            type: 'cacheInvalidation',\n            message: `The following typenames have been invalidated: ${typenames}`,\n            operation,\n            data: { typenames, response },\n          });\n\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.forEach(key => {\n              pendingOperations.add(key);\n            });\n            operations.clear();\n          }\n\n          pendingOperations.forEach(key => {\n            if (resultCache.has(key)) {\n              operation = (resultCache.get(key) as OperationResult).operation;\n              resultCache.delete(key);\n              reexecuteOperation(client, operation);\n            }\n          });\n          // Mark typenames on typenameInvalidate for early invalidation\n        } else if (operation.kind === 'query' && response.data) {\n          resultCache.set(operation.key, response);\n          for (let i = 0; i < typenames.length; i++) {\n            const typeName = typenames[i];\n            const operations =\n              operationCache[typeName] ||\n              (operationCache[typeName] = new Set());\n            operations.add(operation.key);\n          }\n        }\n      })\n    );\n\n    return merge([cachedOps$, forwardedOps$]);\n  };\n};\n\n// Reexecutes a given operation with the default requestPolicy\nconst reexecuteOperation = (client: Client, operation: Operation) => {\n  return client.reexecuteOperation(\n    makeOperation(operation.kind, operation, {\n      ...operation.context,\n      requestPolicy: 'network-only',\n    })\n  );\n};\n","import { pipe, tap } from 'wonka';\nimport { Exchange } from '../types';\n\nexport const debugExchange: Exchange = ({ forward }) => {\n  if (process.env.NODE_ENV === 'production') {\n    return ops$ => forward(ops$);\n  } else {\n    return ops$ =>\n      pipe(\n        ops$,\n        // eslint-disable-next-line no-console\n        tap(op => console.log('[Exchange debug]: Incoming operation: ', op)),\n        forward,\n        tap(result =>\n          // eslint-disable-next-line no-console\n          console.log('[Exchange debug]: Completed operation: ', result)\n        )\n      );\n  }\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Exchange, Operation, OperationResult } from '../types';\n\n/** A default exchange for debouncing GraphQL requests. */\nexport const dedupExchange: Exchange = ({ forward, dispatchDebug }) => {\n  const inFlightKeys = new Set<number>();\n\n  const filterIncomingOperation = (operation: Operation) => {\n    const { key, kind } = operation;\n    if (kind === 'teardown') {\n      inFlightKeys.delete(key);\n      return true;\n    }\n\n    if (kind !== 'query' && kind !== 'subscription') {\n      return true;\n    }\n\n    const isInFlight = inFlightKeys.has(key);\n    inFlightKeys.add(key);\n\n    if (isInFlight) {\n      dispatchDebug({\n        type: 'dedup',\n        message: 'An operation has been deduped.',\n        operation,\n      });\n    }\n\n    return !isInFlight;\n  };\n\n  const afterOperationResult = ({ operation }: OperationResult) => {\n    inFlightKeys.delete(operation.key);\n  };\n\n  return ops$ => {\n    const forward$ = pipe(ops$, filter(filterIncomingOperation));\n    return pipe(forward(forward$), tap(afterOperationResult));\n  };\n};\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { filter, merge, mergeMap, pipe, share, takeUntil, onPush } from 'wonka';\n\nimport { Exchange } from '../types';\nimport {\n  makeFetchBody,\n  makeFetchURL,\n  makeFetchOptions,\n  makeFetchSource,\n} from '../internal';\n\n/** A default exchange for fetching GraphQL requests. */\nexport const fetchExchange: Exchange = ({ forward, dispatchDebug }) => {\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const fetchResults$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind === 'query' || operation.kind === 'mutation';\n      }),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        const body = makeFetchBody(operation);\n        const url = makeFetchURL(operation, body);\n        const fetchOptions = makeFetchOptions(operation, body);\n\n        dispatchDebug({\n          type: 'fetchRequest',\n          message: 'A fetch request is being executed.',\n          operation,\n          data: {\n            url,\n            fetchOptions,\n          },\n        });\n\n        return pipe(\n          makeFetchSource(operation, url, fetchOptions),\n          takeUntil(teardown$),\n          onPush(result => {\n            const error = !result.data ? result.error : undefined;\n\n            dispatchDebug({\n              type: error ? 'fetchError' : 'fetchSuccess',\n              message: `A ${\n                error ? 'failed' : 'successful'\n              } fetch response has been returned.`,\n              operation,\n              data: {\n                url,\n                fetchOptions,\n                value: error || result,\n              },\n            });\n          })\n        );\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(operation => {\n        return operation.kind !== 'query' && operation.kind !== 'mutation';\n      }),\n      forward\n    );\n\n    return merge([fetchResults$, forward$]);\n  };\n};\n","import { filter, pipe, tap } from 'wonka';\nimport { Operation, ExchangeIO, ExchangeInput } from '../types';\nimport { noop } from '../utils';\n\n/** This is always the last exchange in the chain; No operation should ever reach it */\nexport const fallbackExchange: ({\n  dispatchDebug,\n}: Pick<ExchangeInput, 'dispatchDebug'>) => ExchangeIO = ({\n  dispatchDebug,\n}) => ops$ =>\n  pipe(\n    ops$,\n    tap<Operation>(operation => {\n      if (\n        operation.kind !== 'teardown' &&\n        process.env.NODE_ENV !== 'production'\n      ) {\n        const message = `No exchange has handled operations of kind \"${operation.kind}\". Check whether you've added an exchange responsible for these operations.`;\n\n        dispatchDebug({\n          type: 'fallbackCatch',\n          message,\n          operation,\n        });\n        console.warn(message);\n      }\n    }),\n    /* All operations that skipped through the entire exchange chain should be filtered from the output */\n    filter<any>(() => false)\n  );\n\nexport const fallbackExchangeIO: ExchangeIO = fallbackExchange({\n  dispatchDebug: noop,\n});\n","/* eslint-disable @typescript-eslint/no-use-before-define */\n\nimport {\n  filter,\n  makeSubject,\n  onEnd,\n  onStart,\n  pipe,\n  share,\n  Source,\n  take,\n  takeUntil,\n  merge,\n  interval,\n  fromValue,\n  switchMap,\n  publish,\n  subscribe,\n  map,\n  Subscription,\n} from 'wonka';\n\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { DocumentNode } from 'graphql';\n\nimport { composeExchanges, defaultExchanges } from './exchanges';\nimport { fallbackExchange } from './exchanges/fallback';\n\nimport {\n  Exchange,\n  ExchangeInput,\n  GraphQLRequest,\n  Operation,\n  OperationContext,\n  OperationResult,\n  OperationType,\n  RequestPolicy,\n  PromisifiedSource,\n  DebugEvent,\n} from './types';\n\nimport {\n  createRequest,\n  withPromise,\n  maskTypename,\n  noop,\n  makeOperation,\n} from './utils';\n\n/** Options for configuring the URQL [client]{@link Client}. */\nexport interface ClientOptions {\n  /** Target endpoint URL such as `https://my-target:8080/graphql`. */\n  url: string;\n  /** Any additional options to pass to fetch. */\n  fetchOptions?: RequestInit | (() => RequestInit);\n  /** An alternative fetch implementation. */\n  fetch?: typeof fetch;\n  /** An ordered array of Exchanges. */\n  exchanges?: Exchange[];\n  /** Activates support for Suspense. */\n  suspense?: boolean;\n  /** The default request policy for requests. */\n  requestPolicy?: RequestPolicy;\n  /** Use HTTP GET for queries. */\n  preferGetMethod?: boolean;\n  /** Mask __typename from results. */\n  maskTypename?: boolean;\n}\n\ninterface ActiveOperations {\n  [operationKey: string]: number;\n}\n\nexport const createClient = (opts: ClientOptions) => new Client(opts);\n\n/** The URQL application-wide client library. Each execute method starts a GraphQL request and returns a stream of results. */\nexport class Client {\n  /** Start an operation from an exchange */\n  reexecuteOperation: (operation: Operation) => void;\n\n  // Event target for monitoring\n  subscribeToDebugTarget?: (onEvent: (e: DebugEvent) => void) => Subscription;\n\n  // These are variables derived from ClientOptions\n  url: string;\n  fetch?: typeof fetch;\n  fetchOptions?: RequestInit | (() => RequestInit);\n  suspense: boolean;\n  preferGetMethod: boolean;\n  requestPolicy: RequestPolicy;\n  maskTypename: boolean;\n\n  // These are internals to be used to keep track of operations\n  dispatchOperation: (operation?: Operation | void) => void;\n  operations$: Source<Operation>;\n  results$: Source<OperationResult>;\n  activeOperations = Object.create(null) as ActiveOperations;\n  queue: Operation[] = [];\n\n  constructor(opts: ClientOptions) {\n    if (process.env.NODE_ENV !== 'production' && !opts.url) {\n      throw new Error('You are creating an urql-client without a url.');\n    }\n\n    let dispatchDebug: ExchangeInput['dispatchDebug'] = noop;\n    if (process.env.NODE_ENV !== 'production') {\n      const { next, source } = makeSubject<DebugEvent>();\n      this.subscribeToDebugTarget = (onEvent: (e: DebugEvent) => void) =>\n        pipe(source, subscribe(onEvent));\n      dispatchDebug = next as ExchangeInput['dispatchDebug'];\n    }\n\n    this.url = opts.url;\n    this.fetchOptions = opts.fetchOptions;\n    this.fetch = opts.fetch;\n    this.suspense = !!opts.suspense;\n    this.requestPolicy = opts.requestPolicy || 'cache-first';\n    this.preferGetMethod = !!opts.preferGetMethod;\n    this.maskTypename = !!opts.maskTypename;\n\n    // This subject forms the input of operations; executeOperation may be\n    // called to dispatch a new operation on the subject\n    const {\n      source: operations$,\n      next: nextOperation,\n    } = makeSubject<Operation>();\n    this.operations$ = operations$;\n\n    let isOperationBatchActive = false;\n    this.dispatchOperation = (operation?: Operation | void) => {\n      isOperationBatchActive = true;\n      if (operation) nextOperation(operation);\n      while ((operation = this.queue.shift())) nextOperation(operation);\n      isOperationBatchActive = false;\n    };\n\n    this.reexecuteOperation = (operation: Operation) => {\n      // Reexecute operation only if any subscribers are still subscribed to the\n      // operation's exchange results\n      if (\n        operation.kind === 'mutation' ||\n        (this.activeOperations[operation.key] || 0) > 0\n      ) {\n        this.queue.push(operation);\n        if (!isOperationBatchActive) {\n          Promise.resolve().then(this.dispatchOperation);\n        }\n      }\n    };\n\n    const exchanges =\n      opts.exchanges !== undefined ? opts.exchanges : defaultExchanges;\n\n    // All exchange are composed into a single one and are called using the constructed client\n    // and the fallback exchange stream\n    const composedExchange = composeExchanges(exchanges);\n\n    // All exchanges receive inputs using which they can forward operations to the next exchange\n    // and receive a stream of results in return, access the client, or dispatch debugging events\n    // All operations then run through the Exchange IOs in a pipeline-like fashion\n    this.results$ = share(\n      composedExchange({\n        client: this,\n        dispatchDebug,\n        forward: fallbackExchange({ dispatchDebug }),\n      })(this.operations$)\n    );\n\n    // Prevent the `results$` exchange pipeline from being closed by active\n    // cancellations cascading up from components\n    pipe(this.results$, publish);\n  }\n\n  createOperationContext = (\n    opts?: Partial<OperationContext>\n  ): OperationContext => {\n    if (!opts) opts = {};\n\n    return {\n      url: this.url,\n      fetchOptions: this.fetchOptions,\n      fetch: this.fetch,\n      preferGetMethod: this.preferGetMethod,\n      ...opts,\n      suspense: opts.suspense || (opts.suspense !== false && this.suspense),\n      requestPolicy: opts.requestPolicy || this.requestPolicy,\n    };\n  };\n\n  createRequestOperation = <Data = any, Variables = object>(\n    kind: OperationType,\n    request: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext>\n  ): Operation<Data, Variables> =>\n    makeOperation<Data, Variables>(\n      kind,\n      request,\n      this.createOperationContext(opts)\n    );\n\n  /** Counts up the active operation key and dispatches the operation */\n  private onOperationStart(operation: Operation) {\n    const { key } = operation;\n    this.activeOperations[key] = (this.activeOperations[key] || 0) + 1;\n    this.dispatchOperation(operation);\n  }\n\n  /** Deletes an active operation's result observable and sends a teardown signal through the exchange pipeline */\n  private onOperationEnd(operation: Operation) {\n    const { key } = operation;\n    const prevActive = this.activeOperations[key] || 0;\n    const newActive = (this.activeOperations[key] =\n      prevActive <= 0 ? 0 : prevActive - 1);\n    // Check whether this operation has now become inactive\n    if (newActive <= 0) {\n      // Delete all related queued up operations for the inactive one\n      for (let i = this.queue.length - 1; i >= 0; i--)\n        if (this.queue[i].key === operation.key) this.queue.splice(i, 1);\n      // Issue the cancellation teardown operation\n      this.dispatchOperation(\n        makeOperation('teardown', operation, operation.context)\n      );\n    }\n  }\n\n  /** Executes an Operation by sending it through the exchange pipeline It returns an observable that emits all related exchange results and keeps track of this observable's subscribers. A teardown signal will be emitted when no subscribers are listening anymore. */\n  executeRequestOperation<Data = any, Variables = object>(\n    operation: Operation<Data, Variables>\n  ): Source<OperationResult<Data, Variables>> {\n    let operationResults$ = pipe(\n      this.results$,\n      filter((res: OperationResult) => res.operation.key === operation.key)\n    ) as Source<OperationResult<Data, Variables>>;\n\n    if (this.maskTypename) {\n      operationResults$ = pipe(\n        operationResults$,\n        map(res => {\n          res.data = maskTypename(res.data);\n          return res;\n        })\n      );\n    }\n\n    if (operation.kind === 'mutation') {\n      // A mutation is always limited to just a single result and is never shared\n      return pipe(\n        operationResults$,\n        onStart<OperationResult>(() => this.dispatchOperation(operation)),\n        take(1)\n      );\n    }\n\n    const teardown$ = pipe(\n      this.operations$,\n      filter(\n        (op: Operation) => op.kind === 'teardown' && op.key === operation.key\n      )\n    );\n\n    const result$ = pipe(\n      operationResults$,\n      takeUntil(teardown$),\n      onStart<OperationResult>(() => {\n        this.onOperationStart(operation);\n      }),\n      onEnd<OperationResult>(() => {\n        this.onOperationEnd(operation);\n      })\n    );\n\n    if (operation.kind === 'query' && operation.context.pollInterval) {\n      return pipe(\n        merge([fromValue(0), interval(operation.context.pollInterval)]),\n        switchMap(() => result$)\n      );\n    }\n\n    return result$;\n  }\n\n  query<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>> {\n    if (!context || typeof context.suspense !== 'boolean') {\n      context = { ...context, suspense: false };\n    }\n\n    return withPromise<OperationResult<Data, Variables>>(\n      this.executeQuery<Data, Variables>(\n        createRequest(query, variables),\n        context\n      )\n    );\n  }\n\n  readQuery<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): OperationResult<Data, Variables> | null {\n    let result: OperationResult<Data, Variables> | null = null;\n\n    pipe(\n      this.executeQuery(createRequest(query, variables), context),\n      subscribe(res => {\n        result = res;\n      })\n    ).unsubscribe();\n\n    return result;\n  }\n\n  executeQuery = <Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>> => {\n    const operation = this.createRequestOperation('query', query, opts);\n    return this.executeRequestOperation<Data, Variables>(operation);\n  };\n\n  subscription<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>> {\n    return this.executeSubscription<Data, Variables>(\n      createRequest(query, variables),\n      context\n    );\n  }\n\n  executeSubscription = <Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>> => {\n    const operation = this.createRequestOperation('subscription', query, opts);\n    return this.executeRequestOperation<Data, Variables>(operation);\n  };\n\n  mutation<Data = any, Variables extends object = {}>(\n    query: DocumentNode | TypedDocumentNode<Data, Variables> | string,\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ): PromisifiedSource<OperationResult<Data, Variables>> {\n    return withPromise<OperationResult<Data, Variables>>(\n      this.executeMutation<Data, Variables>(\n        createRequest(query, variables),\n        context\n      )\n    );\n  }\n\n  executeMutation = <Data = any, Variables = object>(\n    query: GraphQLRequest<Data, Variables>,\n    opts?: Partial<OperationContext>\n  ): Source<OperationResult<Data, Variables>> => {\n    const operation = this.createRequestOperation('mutation', query, opts);\n    return this.executeRequestOperation<Data, Variables>(operation);\n  };\n}\n","import { GraphQLError } from 'graphql';\nimport { pipe, share, filter, merge, map, tap } from 'wonka';\nimport { Exchange, OperationResult, Operation } from '../types';\nimport { CombinedError } from '../utils';\n\nexport interface SerializedResult {\n  data?: string | undefined; // JSON string of data\n  error?: {\n    graphQLErrors: Array<Partial<GraphQLError> | string>;\n    networkError?: string;\n  };\n}\n\nexport interface SSRData {\n  [key: string]: SerializedResult;\n}\n\nexport interface SSRExchangeParams {\n  isClient?: boolean;\n  initialState?: SSRData;\n}\n\nexport interface SSRExchange extends Exchange {\n  /** Rehydrates cached data */\n  restoreData(data: SSRData): void;\n  /** Extracts cached data */\n  extractData(): SSRData;\n}\n\nconst shouldSkip = ({ kind }: Operation) =>\n  kind !== 'subscription' && kind !== 'query';\n\n/** Serialize an OperationResult to plain JSON */\nconst serializeResult = ({\n  data,\n  error,\n}: OperationResult): SerializedResult => {\n  const result: SerializedResult = {};\n\n  if (data !== undefined) {\n    result.data = JSON.stringify(data);\n  }\n\n  if (error) {\n    result.error = {\n      graphQLErrors: error.graphQLErrors.map(error => {\n        if (!error.path && !error.extensions) return error.message;\n\n        return {\n          message: error.message,\n          path: error.path,\n          extensions: error.extensions,\n        };\n      }),\n    };\n\n    if (error.networkError) {\n      result.error.networkError = '' + error.networkError;\n    }\n  }\n\n  return result;\n};\n\n/** Deserialize plain JSON to an OperationResult */\nconst deserializeResult = (\n  operation: Operation,\n  result: SerializedResult\n): OperationResult => {\n  const { error, data: dataJson } = result;\n\n  const deserialized: OperationResult = {\n    operation,\n    data: dataJson ? JSON.parse(dataJson) : undefined,\n    extensions: undefined,\n    error: error\n      ? new CombinedError({\n          networkError: error.networkError\n            ? new Error(error.networkError)\n            : undefined,\n          graphQLErrors:\n            error.graphQLErrors && error.graphQLErrors.length\n              ? error.graphQLErrors\n              : undefined,\n        })\n      : undefined,\n  };\n\n  return deserialized;\n};\n\n/** The ssrExchange can be created to capture data during SSR and also to rehydrate it on the client */\nexport const ssrExchange = (params?: SSRExchangeParams): SSRExchange => {\n  const data: SSRData = {};\n\n  // On the client-side, we delete results from the cache as they're resolved\n  // this is delayed so that concurrent queries don't delete each other's data\n  const invalidateQueue: number[] = [];\n  const invalidate = (result: OperationResult) => {\n    invalidateQueue.push(result.operation.key);\n    if (invalidateQueue.length === 1) {\n      Promise.resolve().then(() => {\n        let key: number | void;\n        while ((key = invalidateQueue.shift())) delete data[key];\n      });\n    }\n  };\n\n  const isCached = (operation: Operation) => {\n    return !shouldSkip(operation) && data[operation.key] !== undefined;\n  };\n\n  // The SSR Exchange is a temporary cache that can populate results into data for suspense\n  // On the client it can be used to retrieve these temporary results from a rehydrated cache\n  const ssr: SSRExchange = ({ client, forward }) => ops$ => {\n    // params.isClient tells us whether we're on the client-side\n    // By default we assume that we're on the client if suspense-mode is disabled\n    const isClient =\n      params && typeof params.isClient === 'boolean'\n        ? !!params.isClient\n        : !client.suspense;\n\n    const sharedOps$ = share(ops$);\n\n    let forwardedOps$ = pipe(\n      sharedOps$,\n      filter(op => !isCached(op)),\n      forward\n    );\n\n    // NOTE: Since below we might delete the cached entry after accessing\n    // it once, cachedOps$ needs to be merged after forwardedOps$\n    let cachedOps$ = pipe(\n      sharedOps$,\n      filter(op => isCached(op)),\n      map(op => {\n        const serialized = data[op.key];\n        return deserializeResult(op, serialized);\n      })\n    );\n\n    if (!isClient) {\n      // On the server we cache results in the cache as they're resolved\n      forwardedOps$ = pipe(\n        forwardedOps$,\n        tap((result: OperationResult) => {\n          const { operation } = result;\n          if (!shouldSkip(operation)) {\n            const serialized = serializeResult(result);\n            data[operation.key] = serialized;\n          }\n        })\n      );\n    } else {\n      // On the client we delete results from the cache as they're resolved\n      cachedOps$ = pipe(cachedOps$, tap(invalidate));\n    }\n\n    return merge([forwardedOps$, cachedOps$]);\n  };\n\n  ssr.restoreData = (restore: SSRData) => Object.assign(data, restore);\n  ssr.extractData = () => Object.assign({}, data);\n\n  if (params && params.initialState) {\n    ssr.restoreData(params.initialState);\n  }\n\n  return ssr;\n};\n","import { print } from 'graphql';\n\nimport {\n  filter,\n  make,\n  merge,\n  mergeMap,\n  pipe,\n  share,\n  Source,\n  takeUntil,\n} from 'wonka';\n\nimport { makeResult, makeErrorResult, makeOperation } from '../utils';\n\nimport {\n  Exchange,\n  ExecutionResult,\n  Operation,\n  OperationContext,\n  OperationResult,\n} from '../types';\n\nexport interface ObserverLike<T> {\n  next: (value: T) => void;\n  error: (err: any) => void;\n  complete: () => void;\n}\n\n/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */\nexport interface ObservableLike<T> {\n  subscribe(\n    observer: ObserverLike<T>\n  ): {\n    unsubscribe: () => void;\n  };\n}\n\nexport interface SubscriptionOperation {\n  query: string;\n  variables?: Record<string, unknown>;\n  key: string;\n  context: OperationContext;\n}\n\nexport type SubscriptionForwarder = (\n  operation: SubscriptionOperation\n) => ObservableLike<ExecutionResult & { extensions?: Record<string, any> }>;\n\n/** This is called to create a subscription and needs to be hooked up to a transport client. */\nexport interface SubscriptionExchangeOpts {\n  // This has been modelled to work with subscription-transport-ws\n  // See: https://github.com/apollographql/subscriptions-transport-ws#requestoptions--observableexecutionresult-returns-observable-to-execute-the-operation\n  forwardSubscription: SubscriptionForwarder;\n\n  /** This flag may be turned on to allow your subscriptions-transport to handle all operation types */\n  enableAllOperations?: boolean;\n}\n\nexport const subscriptionExchange = ({\n  forwardSubscription,\n  enableAllOperations,\n}: SubscriptionExchangeOpts): Exchange => ({ client, forward }) => {\n  const createSubscriptionSource = (\n    operation: Operation\n  ): Source<OperationResult> => {\n    // This excludes the query's name as a field although subscription-transport-ws does accept it since it's optional\n    const observableish = forwardSubscription({\n      key: operation.key.toString(36),\n      query: print(operation.query),\n      variables: operation.variables,\n      context: { ...operation.context },\n    });\n\n    return make<OperationResult>(({ next, complete }) => {\n      let isComplete = false;\n      let sub;\n\n      Promise.resolve().then(() => {\n        if (isComplete) return;\n\n        sub = observableish.subscribe({\n          next: result => next(makeResult(operation, result)),\n          error: err => next(makeErrorResult(operation, err)),\n          complete: () => {\n            if (!isComplete) {\n              isComplete = true;\n              if (operation.kind === 'subscription') {\n                client.reexecuteOperation(\n                  makeOperation('teardown', operation, operation.context)\n                );\n              }\n\n              complete();\n            }\n          },\n        });\n      });\n\n      return () => {\n        isComplete = true;\n        if (sub) sub.unsubscribe();\n      };\n    });\n  };\n\n  const isSubscriptionOperation = (operation: Operation): boolean => {\n    const { kind } = operation;\n    return (\n      kind === 'subscription' ||\n      (!!enableAllOperations && (kind === 'query' || kind === 'mutation'))\n    );\n  };\n\n  return ops$ => {\n    const sharedOps$ = share(ops$);\n    const subscriptionResults$ = pipe(\n      sharedOps$,\n      filter(isSubscriptionOperation),\n      mergeMap(operation => {\n        const { key } = operation;\n        const teardown$ = pipe(\n          sharedOps$,\n          filter(op => op.kind === 'teardown' && op.key === key)\n        );\n\n        return pipe(createSubscriptionSource(operation), takeUntil(teardown$));\n      })\n    );\n\n    const forward$ = pipe(\n      sharedOps$,\n      filter(op => !isSubscriptionOperation(op)),\n      forward\n    );\n\n    return merge([subscriptionResults$, forward$]);\n  };\n};\n","export interface Warning {\n  key: string;\n  message: string;\n}\n\n/**\n * Module-scoped state to track if deprecation warnings have already been issued\n * for a particular key.\n */\nlet issuedWarnings: Record<string, boolean> = {};\n\n/**\n * If a deprecation warning has not already been issued, use `console.warn()` to\n * issue it with an eye-catching prefix string.\n */\nexport const deprecationWarning = ({ key, message }: Warning) => {\n  if (!issuedWarnings[key]) {\n    console.warn(`[WARNING: Deprecated] ${message}`);\n\n    issuedWarnings[key] = true;\n  }\n};\n\n/**\n * Clears all issued warnings - intended for use in testing.\n */\nexport const _clearWarnings = () => {\n  issuedWarnings = {};\n};\n"]},"metadata":{},"sourceType":"module"}