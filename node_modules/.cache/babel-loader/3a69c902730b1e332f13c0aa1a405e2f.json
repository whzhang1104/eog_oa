{"ast":null,"code":"var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : (obj = {}, obj[\"immer-nothing\"] = true, obj);\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\n\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\n\nfunction isDraftable(value) {\n  if (!value) {\n    return false;\n  }\n\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\n\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  if (Array.isArray(value)) {\n    return true;\n  }\n\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\n\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\n\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\n\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) {\n  return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));\n} : Object.getOwnPropertyNames;\n\nfunction shallowCopy(base, invokeGetters) {\n  if (invokeGetters === void 0) invokeGetters = false;\n\n  if (Array.isArray(base)) {\n    return base.slice();\n  }\n\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\n\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) {\n      cb(i, value[i], value);\n    }\n  } else {\n    ownKeys(value).forEach(function (key) {\n      return cb(key, value[key], value);\n    });\n  }\n}\n\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\n\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\n\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\n\nfunction clone(obj) {\n  if (!isDraftable(obj)) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) {\n    cloned[key] = clone(obj[key]);\n  }\n\n  return cloned;\n}\n\nfunction deepFreeze(obj) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) {\n    return;\n  }\n\n  Object.freeze(obj);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(deepFreeze);\n  } else {\n    for (var key in obj) {\n      deepFreeze(obj[key]);\n    }\n  }\n}\n/** Each scope represents a `produce` call. */\n\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches(patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1() {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave() {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\n\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n} // but share them all instead\n\n\nvar descriptors = {};\n\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n    markChangesSweep(scope.drafts);\n  }\n}\n\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n\n  if (state.finalizing) {\n    return value;\n  } // Create a draft if the value is unmodified.\n\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) {\n      return;\n    }\n\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n\n    if (state.parent) {\n      markChanged(state.parent);\n    }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) {\n    state.copy = clonePotentialDraft(state.base);\n  }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) {\n    throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state)));\n  }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) {\n          markChanged(state);\n        }\n      } else if (hasObjectChanges(state)) {\n        markChanged(state);\n      }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") {\n    return;\n  }\n\n  var state = object[DRAFT_STATE];\n\n  if (!state) {\n    return;\n  }\n\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) {\n        assigned[i] = false;\n      }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) {\n        assigned[i$1] = true;\n      }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) {\n        markChangesRecursively(draft[i$2]);\n      }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n      var value = draft[key];\n      var state$1 = value && value[DRAFT_STATE];\n\n      if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n        return true;\n      }\n    }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n\n  if (draft.length !== state.base.length) {\n    return true;\n  } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) {\n    return true;\n  } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize,\n  createProxy: createProxy\n});\n\nfunction willFinalize$1() {}\n\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\n\nvar objectTraps = {\n  get: get$1,\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) {\n    return state;\n  }\n\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) {\n      return value;\n    } // Store drafts on the copy (when one exists).\n\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n\n    if (isUnchanged) {\n      return true;\n    }\n\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n\n  if (state.copy) {\n    delete state.copy[prop];\n  }\n\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n\n    if (state.parent) {\n      markChanged$1(state.parent);\n    }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n  willFinalize: willFinalize$1,\n  createProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    assign = [copy, base], base = assign[0], copy = assign[1];\n    assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1];\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n\n    if (origValue === value && op === \"replace\") {\n      return;\n    }\n\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nvar applyPatches = function applyPatches(draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n    var path = patch.path;\n    var op = patch.op;\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    if (!path.length) {\n      throw new Error(\"Illegal state\");\n    }\n\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = base[path[i]];\n\n      if (!base || typeof base !== \"object\") {\n        throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\"));\n      } // prettier-ignore\n\n    }\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        // if value is an object, then it's assigned by reference\n        // in the following add or remove ops, the value field inside the patch will also be modifyed\n        // so we use value from the cloned patch\n        base[key] = value;\n        break;\n\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, value);\n        } else {\n          base[key] = value;\n        }\n\n        break;\n\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\n\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce(base, recipe, patchListener) {\n  var this$1 = this; // curried invocation\n\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n      var this$1 = this;\n      if (base === void 0) base = defaultBase;\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return self.produce(base, function (draft) {\n        return recipe.call.apply(recipe, [this$1, draft].concat(args));\n      }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) {\n        scope.revoke();\n      } else {\n        scope.leave();\n      }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n\n    if (result === NOTHING) {\n      return undefined;\n    }\n\n    if (result === undefined) {\n      result = base;\n    }\n\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches(arg1, arg2, arg3) {\n  var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n      var args = [],\n          len = arguments.length - 1;\n\n      while (len-- > 0) {\n        args[len] = arguments[len + 1];\n      }\n\n      return this$1.produceWithPatches(state, function (draft) {\n        return arg1.apply(void 0, [draft].concat(args));\n      });\n    };\n  } // non-curried form\n\n\n  if (arg3) {\n    throw new Error(\"A patch listener cannot be passed to produceWithPatches\");\n  }\n\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft(base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft(draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze(value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies(value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1(base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) {\n    return applyPatches(draft, patches.slice(i + 1));\n  });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult(result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize(draft, path, scope) {\n  var this$1 = this;\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) {\n      return draft;\n    }\n\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) {\n            this.onDelete(state, prop);\n          }\n        }\n      } else {\n        var base = state.base;\n        var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) {\n            this$1.onDelete(state, prop);\n          }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree(root, rootPath, scope) {\n  var this$1 = this;\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function finalizeProperty(prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) {\n        return;\n      }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n      return;\n    } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n    else if (isDraftable(value) && !Object.isFrozen(value)) {\n      each(value, finalizeProperty);\n      this$1.maybeFreeze(value);\n    }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze(value, deep) {\n  if (deep === void 0) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    if (deep) {\n      deepFreeze(value);\n    } else {\n      Object.freeze(value);\n    }\n  }\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };","map":{"version":3,"sources":["../src/common.js","../src/scope.js","../src/es5.js","../src/proxy.js","../src/patches.js","../src/immer.js","../src/index.js"],"names":["NOTHING","Symbol","DRAFTABLE","const","DRAFT_STATE","value","isPlainObject","Array","proto","Object","assign","let","has","target","ownKeys","Reflect","obj","base","clone","key","desc","writable","configurable","i","cb","x","y","isDraftable","cloned","isDraft","deepFreeze","ImmerScope","constructor","usePatches","revoke","leave","draft","descriptors","scope","markChangesRecursively","markChangesSweep","result","isArray","clonePotentialDraft","each","prop","proxyProperty","isEnumerable","parent","state","modified","finalizing","finalized","assigned","copy","revoked","createHiddenProperty","assertUnrevoked","peek","source","prepareCopy","createProxy","is","markChanged","shallowCopy","get","set","JSON","drafts","hasArrayChanges","hasObjectChanges","object","keys","baseValue","descriptor","enumerable","proxy","Proxy","objectTraps","defineProperty","getPrototypeOf","setPrototypeOf","arrayTraps","arguments","fn","isNaN","parseInt","isUnchanged","owner","generateArrayPatches","generateObjectPatches","patches","inversePatches","delta","start","end","path","basePath","op","replaceCount","origValue","applyPatches","patch","configDefaults","useProxies","autoFreeze","process","verifyMinified","onAssign","onDelete","onCopy","Immer","produce","defaultBase","self","recipe","call","patchListener","hasError","this","error","produceWithPatches","arg1","nextState","createDraft","finishDraft","setAutoFreeze","setUseProxies","processResult","baseDraft","isReplaced","finalize","generatePatches","finalizeTree","root","needPatches","finalizeProperty","Error","isDraftProp","rootPath","maybeFreeze","immer"],"mappings":"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","sourcesContent":["var obj;\nvar NOTHING = typeof Symbol !== \"undefined\" ? Symbol(\"immer-nothing\") : ( obj = {}, obj[\"immer-nothing\"] = true, obj );\nvar DRAFTABLE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-draftable\") : \"__$immer_draftable\";\nvar DRAFT_STATE = typeof Symbol !== \"undefined\" && Symbol.for ? Symbol.for(\"immer-state\") : \"__$immer_state\";\nfunction isDraft(value) {\n  return !!value && !!value[DRAFT_STATE];\n}\nfunction isDraftable(value) {\n  if (!value) { return false; }\n  return isPlainObject(value) || !!value[DRAFTABLE] || !!value.constructor[DRAFTABLE];\n}\nfunction isPlainObject(value) {\n  if (!value || typeof value !== \"object\") { return false; }\n  if (Array.isArray(value)) { return true; }\n  var proto = Object.getPrototypeOf(value);\n  return !proto || proto === Object.prototype;\n}\nfunction original(value) {\n  if (value && value[DRAFT_STATE]) {\n    return value[DRAFT_STATE].base;\n  } // otherwise return undefined\n\n}\nvar assign = Object.assign || function assign(target, value) {\n  for (var key in value) {\n    if (has(value, key)) {\n      target[key] = value[key];\n    }\n  }\n\n  return target;\n};\nvar ownKeys = typeof Reflect !== \"undefined\" && Reflect.ownKeys ? Reflect.ownKeys : typeof Object.getOwnPropertySymbols !== \"undefined\" ? function (obj) { return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)); } : Object.getOwnPropertyNames;\nfunction shallowCopy(base, invokeGetters) {\n  if ( invokeGetters === void 0 ) invokeGetters = false;\n\n  if (Array.isArray(base)) { return base.slice(); }\n  var clone = Object.create(Object.getPrototypeOf(base));\n  ownKeys(base).forEach(function (key) {\n    if (key === DRAFT_STATE) {\n      return; // Never copy over draft state.\n    }\n\n    var desc = Object.getOwnPropertyDescriptor(base, key);\n    var value = desc.value;\n\n    if (desc.get) {\n      if (!invokeGetters) {\n        throw new Error(\"Immer drafts cannot have computed properties\");\n      }\n\n      value = desc.get.call(base);\n    }\n\n    if (desc.enumerable) {\n      clone[key] = value;\n    } else {\n      Object.defineProperty(clone, key, {\n        value: value,\n        writable: true,\n        configurable: true\n      });\n    }\n  });\n  return clone;\n}\nfunction each(value, cb) {\n  if (Array.isArray(value)) {\n    for (var i = 0; i < value.length; i++) { cb(i, value[i], value); }\n  } else {\n    ownKeys(value).forEach(function (key) { return cb(key, value[key], value); });\n  }\n}\nfunction isEnumerable(base, prop) {\n  var desc = Object.getOwnPropertyDescriptor(base, prop);\n  return !!desc && desc.enumerable;\n}\nfunction has(thing, prop) {\n  return Object.prototype.hasOwnProperty.call(thing, prop);\n}\nfunction is(x, y) {\n  // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n  if (x === y) {\n    return x !== 0 || 1 / x === 1 / y;\n  } else {\n    return x !== x && y !== y;\n  }\n}\nfunction clone(obj) {\n  if (!isDraftable(obj)) { return obj; }\n  if (Array.isArray(obj)) { return obj.map(clone); }\n  var cloned = Object.create(Object.getPrototypeOf(obj));\n\n  for (var key in obj) { cloned[key] = clone(obj[key]); }\n\n  return cloned;\n}\nfunction deepFreeze(obj) {\n  if (!isDraftable(obj) || isDraft(obj) || Object.isFrozen(obj)) { return; }\n  Object.freeze(obj);\n  if (Array.isArray(obj)) { obj.forEach(deepFreeze); }else { for (var key in obj) { deepFreeze(obj[key]); } }\n}\n\n/** Each scope represents a `produce` call. */\n\nvar ImmerScope = function ImmerScope(parent) {\n  this.drafts = [];\n  this.parent = parent; // Whenever the modified draft contains a draft from another scope, we\n  // need to prevent auto-freezing so the unowned draft can be finalized.\n\n  this.canAutoFreeze = true; // To avoid prototype lookups:\n\n  this.patches = null;\n};\n\nImmerScope.prototype.usePatches = function usePatches (patchListener) {\n  if (patchListener) {\n    this.patches = [];\n    this.inversePatches = [];\n    this.patchListener = patchListener;\n  }\n};\n\nImmerScope.prototype.revoke = function revoke$1 () {\n  this.leave();\n  this.drafts.forEach(revoke);\n  this.drafts = null; // Make draft-related methods throw.\n};\n\nImmerScope.prototype.leave = function leave () {\n  if (this === ImmerScope.current) {\n    ImmerScope.current = this.parent;\n  }\n};\nImmerScope.current = null;\n\nImmerScope.enter = function () {\n  return this.current = new ImmerScope(this.current);\n};\n\nfunction revoke(draft) {\n  draft[DRAFT_STATE].revoke();\n}\n\n// but share them all instead\n\nvar descriptors = {};\nfunction willFinalize(scope, result, isReplaced) {\n  scope.drafts.forEach(function (draft) {\n    draft[DRAFT_STATE].finalizing = true;\n  });\n\n  if (!isReplaced) {\n    if (scope.patches) {\n      markChangesRecursively(scope.drafts[0]);\n    } // This is faster when we don't care about which attributes changed.\n\n\n    markChangesSweep(scope.drafts);\n  } // When a child draft is returned, look for changes.\n  else if (isDraft(result) && result[DRAFT_STATE].scope === scope) {\n      markChangesSweep(scope.drafts);\n    }\n}\nfunction createProxy(base, parent) {\n  var isArray = Array.isArray(base);\n  var draft = clonePotentialDraft(base);\n  each(draft, function (prop) {\n    proxyProperty(draft, prop, isArray || isEnumerable(base, prop));\n  }); // See \"proxy.js\" for property documentation.\n\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    scope: scope,\n    modified: false,\n    finalizing: false,\n    // es5 only\n    finalized: false,\n    assigned: {},\n    parent: parent,\n    base: base,\n    draft: draft,\n    copy: null,\n    revoke: revoke$1,\n    revoked: false // es5 only\n\n  };\n  createHiddenProperty(draft, DRAFT_STATE, state);\n  scope.drafts.push(draft);\n  return draft;\n}\n\nfunction revoke$1() {\n  this.revoked = true;\n}\n\nfunction source(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek(draft, prop) {\n  var state = draft[DRAFT_STATE];\n\n  if (state && !state.finalizing) {\n    state.finalizing = true;\n    var value = draft[prop];\n    state.finalizing = false;\n    return value;\n  }\n\n  return draft[prop];\n}\n\nfunction get(state, prop) {\n  assertUnrevoked(state);\n  var value = peek(source(state), prop);\n  if (state.finalizing) { return value; } // Create a draft if the value is unmodified.\n\n  if (value === peek(state.base, prop) && isDraftable(value)) {\n    prepareCopy(state);\n    return state.copy[prop] = createProxy(value, state);\n  }\n\n  return value;\n}\n\nfunction set(state, prop, value) {\n  assertUnrevoked(state);\n  state.assigned[prop] = true;\n\n  if (!state.modified) {\n    if (is(value, peek(source(state), prop))) { return; }\n    markChanged(state);\n    prepareCopy(state);\n  }\n\n  state.copy[prop] = value;\n}\n\nfunction markChanged(state) {\n  if (!state.modified) {\n    state.modified = true;\n    if (state.parent) { markChanged(state.parent); }\n  }\n}\n\nfunction prepareCopy(state) {\n  if (!state.copy) { state.copy = clonePotentialDraft(state.base); }\n}\n\nfunction clonePotentialDraft(base) {\n  var state = base && base[DRAFT_STATE];\n\n  if (state) {\n    state.finalizing = true;\n    var draft = shallowCopy(state.draft, true);\n    state.finalizing = false;\n    return draft;\n  }\n\n  return shallowCopy(base);\n}\n\nfunction proxyProperty(draft, prop, enumerable) {\n  var desc = descriptors[prop];\n\n  if (desc) {\n    desc.enumerable = enumerable;\n  } else {\n    descriptors[prop] = desc = {\n      configurable: true,\n      enumerable: enumerable,\n\n      get: function get$1() {\n        return get(this[DRAFT_STATE], prop);\n      },\n\n      set: function set$1(value) {\n        set(this[DRAFT_STATE], prop, value);\n      }\n\n    };\n  }\n\n  Object.defineProperty(draft, prop, desc);\n}\n\nfunction assertUnrevoked(state) {\n  if (state.revoked === true) { throw new Error(\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" + JSON.stringify(source(state))); }\n} // This looks expensive, but only proxies are visited, and only objects without known changes are scanned.\n\n\nfunction markChangesSweep(drafts) {\n  // The natural order of drafts in the `scope` array is based on when they\n  // were accessed. By processing drafts in reverse natural order, we have a\n  // better chance of processing leaf nodes first. When a leaf node is known to\n  // have changed, we can avoid any traversal of its ancestor nodes.\n  for (var i = drafts.length - 1; i >= 0; i--) {\n    var state = drafts[i][DRAFT_STATE];\n\n    if (!state.modified) {\n      if (Array.isArray(state.base)) {\n        if (hasArrayChanges(state)) { markChanged(state); }\n      } else if (hasObjectChanges(state)) { markChanged(state); }\n    }\n  }\n}\n\nfunction markChangesRecursively(object) {\n  if (!object || typeof object !== \"object\") { return; }\n  var state = object[DRAFT_STATE];\n  if (!state) { return; }\n  var base = state.base;\n  var draft = state.draft;\n  var assigned = state.assigned;\n\n  if (!Array.isArray(object)) {\n    // Look for added keys.\n    Object.keys(draft).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (base[key] === undefined && !has(base, key)) {\n        assigned[key] = true;\n        markChanged(state);\n      } else if (!assigned[key]) {\n        // Only untouched properties trigger recursion.\n        markChangesRecursively(draft[key]);\n      }\n    }); // Look for removed keys.\n\n    Object.keys(base).forEach(function (key) {\n      // The `undefined` check is a fast path for pre-existing keys.\n      if (draft[key] === undefined && !has(draft, key)) {\n        assigned[key] = false;\n        markChanged(state);\n      }\n    });\n  } else if (hasArrayChanges(state)) {\n    markChanged(state);\n    assigned.length = true;\n\n    if (draft.length < base.length) {\n      for (var i = draft.length; i < base.length; i++) { assigned[i] = false; }\n    } else {\n      for (var i$1 = base.length; i$1 < draft.length; i$1++) { assigned[i$1] = true; }\n    }\n\n    for (var i$2 = 0; i$2 < draft.length; i$2++) {\n      // Only untouched indices trigger recursion.\n      if (assigned[i$2] === undefined) { markChangesRecursively(draft[i$2]); }\n    }\n  }\n}\n\nfunction hasObjectChanges(state) {\n  var base = state.base;\n  var draft = state.draft; // Search for added keys and changed keys. Start at the back, because\n  // non-numeric keys are ordered by time of definition on the object.\n\n  var keys = Object.keys(draft);\n\n  for (var i = keys.length - 1; i >= 0; i--) {\n    var key = keys[i];\n    var baseValue = base[key]; // The `undefined` check is a fast path for pre-existing keys.\n\n    if (baseValue === undefined && !has(base, key)) {\n      return true;\n    } // Once a base key is deleted, future changes go undetected, because its\n    // descriptor is erased. This branch detects any missed changes.\n    else {\n        var value = draft[key];\n        var state$1 = value && value[DRAFT_STATE];\n\n        if (state$1 ? state$1.base !== baseValue : !is(value, baseValue)) {\n          return true;\n        }\n      }\n  } // At this point, no keys were added or changed.\n  // Compare key count to determine if keys were deleted.\n\n\n  return keys.length !== Object.keys(base).length;\n}\n\nfunction hasArrayChanges(state) {\n  var draft = state.draft;\n  if (draft.length !== state.base.length) { return true; } // See #116\n  // If we first shorten the length, our array interceptors will be removed.\n  // If after that new items are added, result in the same original length,\n  // those last items will have no intercepting property.\n  // So if there is no own descriptor on the last position, we know that items were removed and added\n  // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n  // the last one\n\n  var descriptor = Object.getOwnPropertyDescriptor(draft, draft.length - 1); // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n\n  if (descriptor && !descriptor.get) { return true; } // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n\n  return false;\n}\n\nfunction createHiddenProperty(target, prop, value) {\n  Object.defineProperty(target, prop, {\n    value: value,\n    enumerable: false,\n    writable: true\n  });\n}\n\nvar legacyProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize,\n\tcreateProxy: createProxy\n});\n\nfunction willFinalize$1() {}\nfunction createProxy$1(base, parent) {\n  var scope = parent ? parent.scope : ImmerScope.current;\n  var state = {\n    // Track which produce call this is associated with.\n    scope: scope,\n    // True for both shallow and deep changes.\n    modified: false,\n    // Used during finalization.\n    finalized: false,\n    // Track which properties have been assigned (true) or deleted (false).\n    assigned: {},\n    // The parent draft state.\n    parent: parent,\n    // The base state.\n    base: base,\n    // The base proxy.\n    draft: null,\n    // Any property proxies.\n    drafts: {},\n    // The base copy with any updated values.\n    copy: null,\n    // Called by the `produce` function.\n    revoke: null\n  };\n  var ref = Array.isArray(base) ? // [state] is used for arrays, to make sure the proxy is array-ish and not violate invariants,\n  // although state itself is an object\n  Proxy.revocable([state], arrayTraps) : Proxy.revocable(state, objectTraps);\n  var revoke = ref.revoke;\n  var proxy = ref.proxy;\n  state.draft = proxy;\n  state.revoke = revoke;\n  scope.drafts.push(proxy);\n  return proxy;\n}\nvar objectTraps = {\n  get: get$1,\n\n  has: function has(target, prop) {\n    return prop in source$1(target);\n  },\n\n  ownKeys: function ownKeys(target) {\n    return Reflect.ownKeys(source$1(target));\n  },\n\n  set: set$1,\n  deleteProperty: deleteProperty,\n  getOwnPropertyDescriptor: getOwnPropertyDescriptor,\n\n  defineProperty: function defineProperty() {\n    throw new Error(\"Object.defineProperty() cannot be used on an Immer draft\"); // prettier-ignore\n  },\n\n  getPrototypeOf: function getPrototypeOf(target) {\n    return Object.getPrototypeOf(target.base);\n  },\n\n  setPrototypeOf: function setPrototypeOf() {\n    throw new Error(\"Object.setPrototypeOf() cannot be used on an Immer draft\"); // prettier-ignore\n  }\n\n};\nvar arrayTraps = {};\neach(objectTraps, function (key, fn) {\n  arrayTraps[key] = function () {\n    arguments[0] = arguments[0][0];\n    return fn.apply(this, arguments);\n  };\n});\n\narrayTraps.deleteProperty = function (state, prop) {\n  if (isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports deleting array indices\"); // prettier-ignore\n  }\n\n  return objectTraps.deleteProperty.call(this, state[0], prop);\n};\n\narrayTraps.set = function (state, prop, value) {\n  if (prop !== \"length\" && isNaN(parseInt(prop))) {\n    throw new Error(\"Immer only supports setting array indices and the 'length' property\"); // prettier-ignore\n  }\n\n  return objectTraps.set.call(this, state[0], prop, value);\n}; // returns the object we should be reading the current value from, which is base, until some change has been made\n\n\nfunction source$1(state) {\n  return state.copy || state.base;\n} // Access a property without creating an Immer draft.\n\n\nfunction peek$1(draft, prop) {\n  var state = draft[DRAFT_STATE];\n  var desc = Reflect.getOwnPropertyDescriptor(state ? source$1(state) : draft, prop);\n  return desc && desc.value;\n}\n\nfunction get$1(state, prop) {\n  if (prop === DRAFT_STATE) { return state; }\n  var drafts = state.drafts; // Check for existing draft in unmodified state.\n\n  if (!state.modified && has(drafts, prop)) {\n    return drafts[prop];\n  }\n\n  var value = source$1(state)[prop];\n\n  if (state.finalized || !isDraftable(value)) {\n    return value;\n  } // Check for existing draft in modified state.\n\n\n  if (state.modified) {\n    // Assigned values are never drafted. This catches any drafts we created, too.\n    if (value !== peek$1(state.base, prop)) { return value; } // Store drafts on the copy (when one exists).\n\n    drafts = state.copy;\n  }\n\n  return drafts[prop] = createProxy$1(value, state);\n}\n\nfunction set$1(state, prop, value) {\n  if (!state.modified) {\n    var baseValue = peek$1(state.base, prop); // Optimize based on value's truthiness. Truthy values are guaranteed to\n    // never be undefined, so we can avoid the `in` operator. Lastly, truthy\n    // values may be drafts, but falsy values are never drafts.\n\n    var isUnchanged = value ? is(baseValue, value) || value === state.drafts[prop] : is(baseValue, value) && prop in state.base;\n    if (isUnchanged) { return true; }\n    markChanged$1(state);\n  }\n\n  state.assigned[prop] = true;\n  state.copy[prop] = value;\n  return true;\n}\n\nfunction deleteProperty(state, prop) {\n  // The `undefined` check is a fast path for pre-existing keys.\n  if (peek$1(state.base, prop) !== undefined || prop in state.base) {\n    state.assigned[prop] = false;\n    markChanged$1(state);\n  } else if (state.assigned[prop]) {\n    // if an originally not assigned property was deleted\n    delete state.assigned[prop];\n  }\n\n  if (state.copy) { delete state.copy[prop]; }\n  return true;\n} // Note: We never coerce `desc.value` into an Immer draft, because we can't make\n// the same guarantee in ES5 mode.\n\n\nfunction getOwnPropertyDescriptor(state, prop) {\n  var owner = source$1(state);\n  var desc = Reflect.getOwnPropertyDescriptor(owner, prop);\n\n  if (desc) {\n    desc.writable = true;\n    desc.configurable = !Array.isArray(owner) || prop !== \"length\";\n  }\n\n  return desc;\n}\n\nfunction markChanged$1(state) {\n  if (!state.modified) {\n    state.modified = true;\n    state.copy = assign(shallowCopy(state.base), state.drafts);\n    state.drafts = null;\n    if (state.parent) { markChanged$1(state.parent); }\n  }\n}\n\nvar modernProxy = /*#__PURE__*/Object.freeze({\n\twillFinalize: willFinalize$1,\n\tcreateProxy: createProxy$1\n});\n\nfunction generatePatches(state, basePath, patches, inversePatches) {\n  Array.isArray(state.base) ? generateArrayPatches(state, basePath, patches, inversePatches) : generateObjectPatches(state, basePath, patches, inversePatches);\n}\n\nfunction generateArrayPatches(state, basePath, patches, inversePatches) {\n  var assign, assign$1;\n\n  var base = state.base;\n  var copy = state.copy;\n  var assigned = state.assigned; // Reduce complexity by ensuring `base` is never longer.\n\n  if (copy.length < base.length) {\n    (assign = [copy, base], base = assign[0], copy = assign[1]);\n    (assign$1 = [inversePatches, patches], patches = assign$1[0], inversePatches = assign$1[1]);\n  }\n\n  var delta = copy.length - base.length; // Find the first replaced index.\n\n  var start = 0;\n\n  while (base[start] === copy[start] && start < base.length) {\n    ++start;\n  } // Find the last replaced index. Search from the end to optimize splice patches.\n\n\n  var end = base.length;\n\n  while (end > start && base[end - 1] === copy[end + delta - 1]) {\n    --end;\n  } // Process replaced indices.\n\n\n  for (var i = start; i < end; ++i) {\n    if (assigned[i] && copy[i] !== base[i]) {\n      var path = basePath.concat([i]);\n      patches.push({\n        op: \"replace\",\n        path: path,\n        value: copy[i]\n      });\n      inversePatches.push({\n        op: \"replace\",\n        path: path,\n        value: base[i]\n      });\n    }\n  }\n\n  var replaceCount = patches.length; // Process added indices.\n\n  for (var i$1 = end + delta - 1; i$1 >= end; --i$1) {\n    var path$1 = basePath.concat([i$1]);\n    patches[replaceCount + i$1 - end] = {\n      op: \"add\",\n      path: path$1,\n      value: copy[i$1]\n    };\n    inversePatches.push({\n      op: \"remove\",\n      path: path$1\n    });\n  }\n}\n\nfunction generateObjectPatches(state, basePath, patches, inversePatches) {\n  var base = state.base;\n  var copy = state.copy;\n  each(state.assigned, function (key, assignedValue) {\n    var origValue = base[key];\n    var value = copy[key];\n    var op = !assignedValue ? \"remove\" : key in base ? \"replace\" : \"add\";\n    if (origValue === value && op === \"replace\") { return; }\n    var path = basePath.concat(key);\n    patches.push(op === \"remove\" ? {\n      op: op,\n      path: path\n    } : {\n      op: op,\n      path: path,\n      value: value\n    });\n    inversePatches.push(op === \"add\" ? {\n      op: \"remove\",\n      path: path\n    } : op === \"remove\" ? {\n      op: \"add\",\n      path: path,\n      value: origValue\n    } : {\n      op: \"replace\",\n      path: path,\n      value: origValue\n    });\n  });\n}\n\nvar applyPatches = function (draft, patches) {\n  for (var i$1 = 0, list = patches; i$1 < list.length; i$1 += 1) {\n    var patch = list[i$1];\n\n    var path = patch.path;\n    var op = patch.op;\n    var value = clone(patch.value); // used to clone patch to ensure original patch is not modified, see #411\n\n    if (!path.length) { throw new Error(\"Illegal state\"); }\n    var base = draft;\n\n    for (var i = 0; i < path.length - 1; i++) {\n      base = base[path[i]];\n      if (!base || typeof base !== \"object\") { throw new Error(\"Cannot apply patch, path doesn't resolve: \" + path.join(\"/\")); } // prettier-ignore\n    }\n\n    var key = path[path.length - 1];\n\n    switch (op) {\n      case \"replace\":\n        // if value is an object, then it's assigned by reference\n        // in the following add or remove ops, the value field inside the patch will also be modifyed\n        // so we use value from the cloned patch\n        base[key] = value;\n        break;\n\n      case \"add\":\n        if (Array.isArray(base)) {\n          // TODO: support \"foo/-\" paths for appending to an array\n          base.splice(key, 0, value);\n        } else {\n          base[key] = value;\n        }\n\n        break;\n\n      case \"remove\":\n        if (Array.isArray(base)) {\n          base.splice(key, 1);\n        } else {\n          delete base[key];\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unsupported patch operation: \" + op);\n    }\n  }\n\n  return draft;\n};\n\nfunction verifyMinified() {}\n\nvar configDefaults = {\n  useProxies: typeof Proxy !== \"undefined\" && typeof Proxy.revocable !== \"undefined\" && typeof Reflect !== \"undefined\",\n  autoFreeze: typeof process !== \"undefined\" ? process.env.NODE_ENV !== \"production\" : verifyMinified.name === \"verifyMinified\",\n  onAssign: null,\n  onDelete: null,\n  onCopy: null\n};\nvar Immer = function Immer(config) {\n  assign(this, configDefaults, config);\n  this.setUseProxies(this.useProxies);\n  this.produce = this.produce.bind(this);\n};\n\nImmer.prototype.produce = function produce (base, recipe, patchListener) {\n    var this$1 = this;\n\n  // curried invocation\n  if (typeof base === \"function\" && typeof recipe !== \"function\") {\n    var defaultBase = recipe;\n    recipe = base;\n    var self = this;\n    return function curriedProduce(base) {\n        var this$1 = this;\n        if ( base === void 0 ) base = defaultBase;\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n      return self.produce(base, function (draft) { return recipe.call.apply(recipe, [ this$1, draft ].concat( args )); }); // prettier-ignore\n    };\n  } // prettier-ignore\n\n\n  {\n    if (typeof recipe !== \"function\") {\n      throw new Error(\"The first or second argument to `produce` must be a function\");\n    }\n\n    if (patchListener !== undefined && typeof patchListener !== \"function\") {\n      throw new Error(\"The third argument to `produce` must be a function or undefined\");\n    }\n  }\n  var result; // Only plain objects, arrays, and \"immerable classes\" are drafted.\n\n  if (isDraftable(base)) {\n    var scope = ImmerScope.enter();\n    var proxy = this.createProxy(base);\n    var hasError = true;\n\n    try {\n      result = recipe(proxy);\n      hasError = false;\n    } finally {\n      // finally instead of catch + rethrow better preserves original stack\n      if (hasError) { scope.revoke(); }else { scope.leave(); }\n    }\n\n    if (result instanceof Promise) {\n      return result.then(function (result) {\n        scope.usePatches(patchListener);\n        return this$1.processResult(result, scope);\n      }, function (error) {\n        scope.revoke();\n        throw error;\n      });\n    }\n\n    scope.usePatches(patchListener);\n    return this.processResult(result, scope);\n  } else {\n    result = recipe(base);\n    if (result === NOTHING) { return undefined; }\n    if (result === undefined) { result = base; }\n    this.maybeFreeze(result, true);\n    return result;\n  }\n};\n\nImmer.prototype.produceWithPatches = function produceWithPatches (arg1, arg2, arg3) {\n    var this$1 = this;\n\n  if (typeof arg1 === \"function\") {\n    return function (state) {\n        var args = [], len = arguments.length - 1;\n        while ( len-- > 0 ) args[ len ] = arguments[ len + 1 ];\n\n        return this$1.produceWithPatches(state, function (draft) { return arg1.apply(void 0, [ draft ].concat( args )); });\n      };\n  } // non-curried form\n\n\n  if (arg3) { throw new Error(\"A patch listener cannot be passed to produceWithPatches\"); }\n  var patches, inversePatches;\n  var nextState = this.produce(arg1, arg2, function (p, ip) {\n    patches = p;\n    inversePatches = ip;\n  });\n  return [nextState, patches, inversePatches];\n};\n\nImmer.prototype.createDraft = function createDraft (base) {\n  if (!isDraftable(base)) {\n    throw new Error(\"First argument to `createDraft` must be a plain object, an array, or an immerable object\"); // prettier-ignore\n  }\n\n  var scope = ImmerScope.enter();\n  var proxy = this.createProxy(base);\n  proxy[DRAFT_STATE].isManual = true;\n  scope.leave();\n  return proxy;\n};\n\nImmer.prototype.finishDraft = function finishDraft (draft, patchListener) {\n  var state = draft && draft[DRAFT_STATE];\n\n  if (!state || !state.isManual) {\n    throw new Error(\"First argument to `finishDraft` must be a draft returned by `createDraft`\"); // prettier-ignore\n  }\n\n  if (state.finalized) {\n    throw new Error(\"The given draft is already finalized\"); // prettier-ignore\n  }\n\n  var scope = state.scope;\n  scope.usePatches(patchListener);\n  return this.processResult(undefined, scope);\n};\n\nImmer.prototype.setAutoFreeze = function setAutoFreeze (value) {\n  this.autoFreeze = value;\n};\n\nImmer.prototype.setUseProxies = function setUseProxies (value) {\n  this.useProxies = value;\n  assign(this, value ? modernProxy : legacyProxy);\n};\n\nImmer.prototype.applyPatches = function applyPatches$1 (base, patches) {\n  // If a patch replaces the entire state, take that replacement as base\n  // before applying patches\n  var i;\n\n  for (i = patches.length - 1; i >= 0; i--) {\n    var patch = patches[i];\n\n    if (patch.path.length === 0 && patch.op === \"replace\") {\n      base = patch.value;\n      break;\n    }\n  }\n\n  if (isDraft(base)) {\n    // N.B: never hits if some patch a replacement, patches are never drafts\n    return applyPatches(base, patches);\n  } // Otherwise, produce a copy of the base state.\n\n\n  return this.produce(base, function (draft) { return applyPatches(draft, patches.slice(i + 1)); });\n};\n/** @internal */\n\n\nImmer.prototype.processResult = function processResult (result, scope) {\n  var baseDraft = scope.drafts[0];\n  var isReplaced = result !== undefined && result !== baseDraft;\n  this.willFinalize(scope, result, isReplaced);\n\n  if (isReplaced) {\n    if (baseDraft[DRAFT_STATE].modified) {\n      scope.revoke();\n      throw new Error(\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"); // prettier-ignore\n    }\n\n    if (isDraftable(result)) {\n      // Finalize the result in case it contains (or is) a subset of the draft.\n      result = this.finalize(result, null, scope);\n      this.maybeFreeze(result);\n    }\n\n    if (scope.patches) {\n      scope.patches.push({\n        op: \"replace\",\n        path: [],\n        value: result\n      });\n      scope.inversePatches.push({\n        op: \"replace\",\n        path: [],\n        value: baseDraft[DRAFT_STATE].base\n      });\n    }\n  } else {\n    // Finalize the base draft.\n    result = this.finalize(baseDraft, [], scope);\n  }\n\n  scope.revoke();\n\n  if (scope.patches) {\n    scope.patchListener(scope.patches, scope.inversePatches);\n  }\n\n  return result !== NOTHING ? result : undefined;\n};\n/**\n * @internal\n * Finalize a draft, returning either the unmodified base state or a modified\n * copy of the base state.\n */\n\n\nImmer.prototype.finalize = function finalize (draft, path, scope) {\n    var this$1 = this;\n\n  var state = draft[DRAFT_STATE];\n\n  if (!state) {\n    if (Object.isFrozen(draft)) { return draft; }\n    return this.finalizeTree(draft, null, scope);\n  } // Never finalize drafts owned by another scope.\n\n\n  if (state.scope !== scope) {\n    return draft;\n  }\n\n  if (!state.modified) {\n    this.maybeFreeze(state.base, true);\n    return state.base;\n  }\n\n  if (!state.finalized) {\n    state.finalized = true;\n    this.finalizeTree(state.draft, path, scope);\n\n    if (this.onDelete) {\n      // The `assigned` object is unreliable with ES5 drafts.\n      if (this.useProxies) {\n        var assigned = state.assigned;\n\n        for (var prop in assigned) {\n          if (!assigned[prop]) { this.onDelete(state, prop); }\n        }\n      } else {\n        var base = state.base;\n          var copy = state.copy;\n        each(base, function (prop) {\n          if (!has(copy, prop)) { this$1.onDelete(state, prop); }\n        });\n      }\n    }\n\n    if (this.onCopy) {\n      this.onCopy(state);\n    } // At this point, all descendants of `state.copy` have been finalized,\n    // so we can be sure that `scope.canAutoFreeze` is accurate.\n\n\n    if (this.autoFreeze && scope.canAutoFreeze) {\n      Object.freeze(state.copy);\n    }\n\n    if (path && scope.patches) {\n      generatePatches(state, path, scope.patches, scope.inversePatches);\n    }\n  }\n\n  return state.copy;\n};\n/**\n * @internal\n * Finalize all drafts in the given state tree.\n */\n\n\nImmer.prototype.finalizeTree = function finalizeTree (root, rootPath, scope) {\n    var this$1 = this;\n\n  var state = root[DRAFT_STATE];\n\n  if (state) {\n    if (!this.useProxies) {\n      // Create the final copy, with added keys and without deleted keys.\n      state.copy = shallowCopy(state.draft, true);\n    }\n\n    root = state.copy;\n  }\n\n  var needPatches = !!rootPath && !!scope.patches;\n\n  var finalizeProperty = function (prop, value, parent) {\n    if (value === parent) {\n      throw Error(\"Immer forbids circular references\");\n    } // In the `finalizeTree` method, only the `root` object may be a draft.\n\n\n    var isDraftProp = !!state && parent === root;\n\n    if (isDraft(value)) {\n      var path = isDraftProp && needPatches && !state.assigned[prop] ? rootPath.concat(prop) : null; // Drafts owned by `scope` are finalized here.\n\n      value = this$1.finalize(value, path, scope); // Drafts from another scope must prevent auto-freezing.\n\n      if (isDraft(value)) {\n        scope.canAutoFreeze = false;\n      } // Preserve non-enumerable properties.\n\n\n      if (Array.isArray(parent) || isEnumerable(parent, prop)) {\n        parent[prop] = value;\n      } else {\n        Object.defineProperty(parent, prop, {\n          value: value\n        });\n      } // Unchanged drafts are never passed to the `onAssign` hook.\n\n\n      if (isDraftProp && value === state.base[prop]) { return; }\n    } // Unchanged draft properties are ignored.\n    else if (isDraftProp && is(value, state.base[prop])) {\n        return;\n      } // Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n      else if (isDraftable(value) && !Object.isFrozen(value)) {\n          each(value, finalizeProperty);\n          this$1.maybeFreeze(value);\n        }\n\n    if (isDraftProp && this$1.onAssign) {\n      this$1.onAssign(state, prop, value);\n    }\n  };\n\n  each(root, finalizeProperty);\n  return root;\n};\n\nImmer.prototype.maybeFreeze = function maybeFreeze (value, deep) {\n    if ( deep === void 0 ) deep = false;\n\n  if (this.autoFreeze && !isDraft(value)) {\n    if (deep) { deepFreeze(value); }else { Object.freeze(value); }\n  }\n};\n\nvar immer = new Immer();\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\n\nvar produce = immer.produce;\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\n\nvar produceWithPatches = immer.produceWithPatches.bind(immer);\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * By default, auto-freezing is disabled in production.\n */\n\nvar setAutoFreeze = immer.setAutoFreeze.bind(immer);\n/**\n * Pass true to use the ES2015 `Proxy` class when creating drafts, which is\n * always faster than using ES5 proxies.\n *\n * By default, feature detection is used, so calling this is rarely necessary.\n */\n\nvar setUseProxies = immer.setUseProxies.bind(immer);\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\n\nvar applyPatches$1 = immer.applyPatches.bind(immer);\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\n\nvar createDraft = immer.createDraft.bind(immer);\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\n\nvar finishDraft = immer.finishDraft.bind(immer);\n\nexport default produce;\nexport { Immer, applyPatches$1 as applyPatches, createDraft, finishDraft, DRAFTABLE as immerable, isDraft, isDraftable, NOTHING as nothing, original, produce, produceWithPatches, setAutoFreeze, setUseProxies };\n//# sourceMappingURL=immer.module.js.map\n"]},"metadata":{},"sourceType":"module"}