{"version":3,"file":"redux-starter-kit.cjs.development.js","sources":["../src/isPlainObject.ts","../src/serializableStateInvariantMiddleware.ts","../src/getDefaultMiddleware.ts","../src/configureStore.ts","../src/createAction.ts","../src/createReducer.ts","../src/createSlice.ts"],"sourcesContent":["/**\r\n * Returns true if the passed value is \"plain\" object, i.e. an object whose\r\n * protoype is the root `Object.prototype`. This includes objects created\r\n * using object literals, but not for instance for class instances.\r\n *\r\n * @param {any} value The value to inspect.\r\n * @returns {boolean} True if the argument appears to be a plain object.\r\n */\r\nexport default function isPlainObject(value: unknown): value is object {\r\n  if (typeof value !== 'object' || value === null) return false\r\n\r\n  let proto = value\r\n  while (Object.getPrototypeOf(proto) !== null) {\r\n    proto = Object.getPrototypeOf(proto)\r\n  }\r\n\r\n  return Object.getPrototypeOf(value) === proto\r\n}\r\n","import isPlainObject from './isPlainObject'\r\nimport { Middleware } from 'redux'\r\n\r\n/**\r\n * Returns true if the passed value is \"plain\", i.e. a value that is either\r\n * directly JSON-serializable (boolean, number, string, array, plain object)\r\n * or `undefined`.\r\n *\r\n * @param val The value to check.\r\n */\r\nexport function isPlain(val: any) {\r\n  return (\r\n    typeof val === 'undefined' ||\r\n    val === null ||\r\n    typeof val === 'string' ||\r\n    typeof val === 'boolean' ||\r\n    typeof val === 'number' ||\r\n    Array.isArray(val) ||\r\n    isPlainObject(val)\r\n  )\r\n}\r\n\r\nconst NON_SERIALIZABLE_STATE_MESSAGE = [\r\n  'A non-serializable value was detected in the state, in the path: `%s`. Value: %o',\r\n  'Take a look at the reducer(s) handling this action type: %s.',\r\n  '(See https://redux.js.org/faq/organizing-state#can-i-put-functions-promises-or-other-non-serializable-items-in-my-store-state)'\r\n].join('\\n')\r\n\r\nconst NON_SERIALIZABLE_ACTION_MESSAGE = [\r\n  'A non-serializable value was detected in an action, in the path: `%s`. Value: %o',\r\n  'Take a look at the logic that dispatched this action:  %o.',\r\n  '(See https://redux.js.org/faq/actions#why-should-type-be-a-string-or-at-least-serializable-why-should-my-action-types-be-constants)'\r\n].join('\\n')\r\n\r\ninterface NonSerializableValue {\r\n  keyPath: string\r\n  value: unknown\r\n}\r\n\r\nexport function findNonSerializableValue(\r\n  value: unknown,\r\n  path: ReadonlyArray<string> = [],\r\n  isSerializable: (value: unknown) => boolean = isPlain,\r\n  getEntries?: (value: unknown) => [string, any][]\r\n): NonSerializableValue | false {\r\n  let foundNestedSerializable: NonSerializableValue | false\r\n\r\n  if (!isSerializable(value)) {\r\n    return {\r\n      keyPath: path.join('.') || '<root>',\r\n      value: value\r\n    }\r\n  }\r\n\r\n  if (typeof value !== 'object' || value === null) {\r\n    return false\r\n  }\r\n\r\n  const entries = getEntries != null ? getEntries(value) : Object.entries(value)\r\n\r\n  for (const [property, nestedValue] of entries) {\r\n    const nestedPath = path.concat(property)\r\n\r\n    if (!isSerializable(nestedValue)) {\r\n      return {\r\n        keyPath: nestedPath.join('.'),\r\n        value: nestedValue\r\n      }\r\n    }\r\n\r\n    if (typeof nestedValue === 'object') {\r\n      foundNestedSerializable = findNonSerializableValue(\r\n        nestedValue,\r\n        nestedPath,\r\n        isSerializable,\r\n        getEntries\r\n      )\r\n\r\n      if (foundNestedSerializable) {\r\n        return foundNestedSerializable\r\n      }\r\n    }\r\n  }\r\n\r\n  return false\r\n}\r\n\r\n/**\r\n * Options for `createSerializableStateInvariantMiddleware()`.\r\n */\r\nexport interface SerializableStateInvariantMiddlewareOptions {\r\n  /**\r\n   * The function to check if a value is considered serializable. This\r\n   * function is applied recursively to every value contained in the\r\n   * state. Defaults to `isPlain()`.\r\n   */\r\n  isSerializable?: (value: any) => boolean\r\n  /**\r\n   * The function that will be used to retrieve entries from each\r\n   * value.  If unspecified, `Object.entries` will be used. Defaults\r\n   * to `undefined`.\r\n   */\r\n  getEntries?: (value: any) => [string, any][]\r\n\r\n  /**\r\n   * An array of action types to ignore when checking for serializability, Defaults to []\r\n   */\r\n  ignoredActions?: string[]\r\n}\r\n\r\n/**\r\n * Creates a middleware that, after every state change, checks if the new\r\n * state is serializable. If a non-serializable value is found within the\r\n * state, an error is printed to the console.\r\n *\r\n * @param options Middleware options.\r\n */\r\nexport function createSerializableStateInvariantMiddleware(\r\n  options: SerializableStateInvariantMiddlewareOptions = {}\r\n): Middleware {\r\n  const { isSerializable = isPlain, getEntries, ignoredActions = [] } = options\r\n\r\n  return storeAPI => next => action => {\r\n    if (ignoredActions.length && ignoredActions.indexOf(action.type) !== -1) {\r\n      return next(action)\r\n    }\r\n\r\n    const foundActionNonSerializableValue = findNonSerializableValue(\r\n      action,\r\n      [],\r\n      isSerializable,\r\n      getEntries\r\n    )\r\n\r\n    if (foundActionNonSerializableValue) {\r\n      const { keyPath, value } = foundActionNonSerializableValue\r\n\r\n      console.error(NON_SERIALIZABLE_ACTION_MESSAGE, keyPath, value, action)\r\n    }\r\n\r\n    const result = next(action)\r\n\r\n    const state = storeAPI.getState()\r\n\r\n    const foundStateNonSerializableValue = findNonSerializableValue(\r\n      state,\r\n      [],\r\n      isSerializable,\r\n      getEntries\r\n    )\r\n\r\n    if (foundStateNonSerializableValue) {\r\n      const { keyPath, value } = foundStateNonSerializableValue\r\n\r\n      console.error(NON_SERIALIZABLE_STATE_MESSAGE, keyPath, value, action.type)\r\n    }\r\n\r\n    return result\r\n  }\r\n}\r\n","import { Middleware } from 'redux'\r\nimport thunkMiddleware from 'redux-thunk'\r\n// UMD-DEV-ONLY: import createImmutableStateInvariantMiddleware from 'redux-immutable-state-invariant'\r\n\r\nimport {\r\n  createSerializableStateInvariantMiddleware,\r\n  SerializableStateInvariantMiddlewareOptions\r\n} from './serializableStateInvariantMiddleware'\r\n\r\nfunction isBoolean(x: any): x is boolean {\r\n  return typeof x === 'boolean'\r\n}\r\n\r\ninterface ThunkOptions<E = any> {\r\n  extraArgument: E\r\n}\r\n\r\ninterface ImmutableStateInvariantMiddlewareOptions {\r\n  isImmutable?: (value: any) => boolean\r\n  ignore?: string[]\r\n}\r\n\r\ninterface GetDefaultMiddlewareOptions {\r\n  thunk?: boolean | ThunkOptions\r\n  immutableCheck?: boolean | ImmutableStateInvariantMiddlewareOptions\r\n  serializableCheck?: boolean | SerializableStateInvariantMiddlewareOptions\r\n}\r\n\r\n/**\r\n * Returns any array containing the default middleware installed by\r\n * `configureStore()`. Useful if you want to configure your store with a custom\r\n * `middleware` array but still keep the default set.\r\n *\r\n * @return The default middleware used by `configureStore()`.\r\n */\r\nexport function getDefaultMiddleware<S = any>(\r\n  options: GetDefaultMiddlewareOptions = {}\r\n): Middleware<{}, S>[] {\r\n  const {\r\n    thunk = true,\r\n    immutableCheck = true,\r\n    serializableCheck = true\r\n  } = options\r\n\r\n  let middlewareArray: Middleware<{}, S>[] = []\r\n\r\n  if (thunk) {\r\n    if (isBoolean(thunk)) {\r\n      middlewareArray.push(thunkMiddleware)\r\n    } else {\r\n      middlewareArray.push(\r\n        thunkMiddleware.withExtraArgument(thunk.extraArgument)\r\n      )\r\n    }\r\n  }\r\n\r\n  if (process.env.NODE_ENV !== 'production') {\r\n    /* START_REMOVE_UMD */\r\n    if (immutableCheck) {\r\n      const createImmutableStateInvariantMiddleware = require('redux-immutable-state-invariant')\r\n        .default\r\n\r\n      let immutableOptions: ImmutableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(immutableCheck)) {\r\n        immutableOptions = immutableCheck\r\n      }\r\n\r\n      middlewareArray.unshift(\r\n        createImmutableStateInvariantMiddleware(immutableOptions)\r\n      )\r\n    }\r\n\r\n    /* STOP_REMOVE_UMD */\r\n\r\n    if (serializableCheck) {\r\n      let serializableOptions: SerializableStateInvariantMiddlewareOptions = {}\r\n\r\n      if (!isBoolean(serializableCheck)) {\r\n        serializableOptions = serializableCheck\r\n      }\r\n\r\n      middlewareArray.push(\r\n        createSerializableStateInvariantMiddleware(serializableOptions)\r\n      )\r\n    }\r\n  }\r\n\r\n  return middlewareArray\r\n}\r\n","import {\r\n  createStore,\r\n  compose,\r\n  applyMiddleware,\r\n  combineReducers,\r\n  Reducer,\r\n  ReducersMapObject,\r\n  Middleware,\r\n  Action,\r\n  AnyAction,\r\n  StoreEnhancer,\r\n  Store,\r\n  DeepPartial\r\n} from 'redux'\r\nimport {\r\n  composeWithDevTools,\r\n  EnhancerOptions as DevToolsOptions\r\n} from 'redux-devtools-extension'\r\nimport { ThunkDispatch } from 'redux-thunk'\r\n\r\nimport isPlainObject from './isPlainObject'\r\nimport { getDefaultMiddleware } from './getDefaultMiddleware'\r\n\r\nconst IS_PRODUCTION = process.env.NODE_ENV === 'production'\r\n\r\nexport type ConfigureEnhancersCallback = (\r\n  defaultEnhancers: StoreEnhancer[]\r\n) => StoreEnhancer[]\r\n\r\n/**\r\n * Options for `configureStore()`.\r\n */\r\nexport interface ConfigureStoreOptions<S = any, A extends Action = AnyAction> {\r\n  /**\r\n   * A single reducer function that will be used as the root reducer, or an\r\n   * object of slice reducers that will be passed to `combineReducers()`.\r\n   */\r\n  reducer: Reducer<S, A> | ReducersMapObject<S, A>\r\n\r\n  /**\r\n   * An array of Redux middleware to install. If not supplied, defaults to\r\n   * the set of middleware returned by `getDefaultMiddleware()`.\r\n   */\r\n  middleware?: Middleware<{}, S>[]\r\n\r\n  /**\r\n   * Whether to enable Redux DevTools integration. Defaults to `true`.\r\n   *\r\n   * Additional configuration can be done by passing Redux DevTools options\r\n   */\r\n  devTools?: boolean | DevToolsOptions\r\n\r\n  /**\r\n   * The initial state, same as Redux's createStore.\r\n   * You may optionally specify it to hydrate the state\r\n   * from the server in universal apps, or to restore a previously serialized\r\n   * user session. If you use `combineReducers()` to produce the root reducer\r\n   * function (either directly or indirectly by passing an object as `reducer`),\r\n   * this must be an object with the same shape as the reducer map keys.\r\n   */\r\n  // NOTE: The needlessly complicated `S extends any ? S : S` instead of just\r\n  // `S` ensures that the TypeScript compiler doesn't attempt to infer `S`\r\n  // based on the value passed as `preloadedState`, which might be a partial\r\n  // state rather than the full thing.\r\n  preloadedState?: DeepPartial<S extends any ? S : S>\r\n\r\n  /**\r\n   * The store enhancers to apply. See Redux's `createStore()`.\r\n   * All enhancers will be included before the DevTools Extension enhancer.\r\n   * If you need to customize the order of enhancers, supply a callback\r\n   * function that will receive the original array (ie, `[applyMiddleware]`),\r\n   * and should return a new array (such as `[applyMiddleware, offline]`).\r\n   * If you only need to add middleware, you can use the `middleware` parameter instaead.\r\n   */\r\n  enhancers?: StoreEnhancer[] | ConfigureEnhancersCallback\r\n}\r\n\r\n/**\r\n * A Redux store returned by `configureStore()`. Supports dispatching\r\n * side-effectful _thunks_ in addition to plain actions.\r\n */\r\nexport interface EnhancedStore<S = any, A extends Action = AnyAction>\r\n  extends Store<S, A> {\r\n  dispatch: ThunkDispatch<S, any, A>\r\n}\r\n\r\n/**\r\n * A friendly abstraction over the standard Redux `createStore()` function.\r\n *\r\n * @param config The store configuration.\r\n * @returns A configured Redux store.\r\n */\r\nexport function configureStore<S = any, A extends Action = AnyAction>(\r\n  options: ConfigureStoreOptions<S, A>\r\n): EnhancedStore<S, A> {\r\n  const {\r\n    reducer = undefined,\r\n    middleware = getDefaultMiddleware(),\r\n    devTools = true,\r\n    preloadedState = undefined,\r\n    enhancers = undefined\r\n  } = options || {}\r\n\r\n  let rootReducer: Reducer<S, A>\r\n\r\n  if (typeof reducer === 'function') {\r\n    rootReducer = reducer\r\n  } else if (isPlainObject(reducer)) {\r\n    rootReducer = combineReducers(reducer)\r\n  } else {\r\n    throw new Error(\r\n      '\"reducer\" is a required argument, and must be a function or an object of functions that can be passed to combineReducers'\r\n    )\r\n  }\r\n\r\n  const middlewareEnhancer = applyMiddleware(...middleware)\r\n\r\n  let finalCompose = compose\r\n\r\n  if (devTools) {\r\n    finalCompose = composeWithDevTools({\r\n      // Enable capture of stack traces for dispatched Redux actions\r\n      trace: !IS_PRODUCTION,\r\n      ...(typeof devTools === 'object' && devTools)\r\n    })\r\n  }\r\n\r\n  let storeEnhancers: StoreEnhancer[] = [middlewareEnhancer]\r\n\r\n  if (Array.isArray(enhancers)) {\r\n    storeEnhancers = [middlewareEnhancer, ...enhancers]\r\n  } else if (typeof enhancers === 'function') {\r\n    storeEnhancers = enhancers(storeEnhancers)\r\n  }\r\n\r\n  const composedEnhancer = finalCompose(...storeEnhancers) as StoreEnhancer\r\n\r\n  return createStore(\r\n    rootReducer,\r\n    preloadedState as DeepPartial<S>,\r\n    composedEnhancer\r\n  )\r\n}\r\n","import { Action } from 'redux'\r\nimport { IsUnknownOrNonInferrable } from './tsHelpers'\r\n\r\n/**\r\n * An action with a string type and an associated payload. This is the\r\n * type of action returned by `createAction()` action creators.\r\n *\r\n * @template P The type of the action's payload.\r\n * @template T the type used for the action type.\r\n * @template M The type of the action's meta (optional)\r\n * @template E The type of the action's error (optional)\r\n */\r\nexport type PayloadAction<\r\n  P = void,\r\n  T extends string = string,\r\n  M = never,\r\n  E = never\r\n> = WithOptional<M, E, WithPayload<P, Action<T>>>\r\n\r\nexport type PrepareAction<P> =\r\n  | ((...args: any[]) => { payload: P })\r\n  | ((...args: any[]) => { payload: P; meta: any })\r\n  | ((...args: any[]) => { payload: P; error: any })\r\n  | ((...args: any[]) => { payload: P; meta: any; error: any })\r\n\r\nexport type ActionCreatorWithPreparedPayload<\r\n  PA extends PrepareAction<any> | void,\r\n  T extends string = string\r\n> = PA extends PrepareAction<infer P>\r\n  ? WithTypePropertyAndMatch<\r\n      (\r\n        ...args: Parameters<PA>\r\n      ) => PayloadAction<P, T, MetaOrNever<PA>, ErrorOrNever<PA>>,\r\n      T,\r\n      P,\r\n      MetaOrNever<PA>,\r\n      ErrorOrNever<PA>\r\n    >\r\n  : void\r\n\r\nexport type ActionCreatorWithOptionalPayload<\r\n  P,\r\n  T extends string = string\r\n> = WithTypePropertyAndMatch<\r\n  {\r\n    (payload?: undefined): PayloadAction<undefined, T>\r\n    <PT extends Diff<P, undefined>>(payload?: PT): PayloadAction<PT, T>\r\n  },\r\n  T,\r\n  P | undefined\r\n>\r\n\r\nexport type ActionCreatorWithoutPayload<\r\n  T extends string = string\r\n> = WithTypePropertyAndMatch<() => PayloadAction<undefined, T>, T, undefined>\r\n\r\nexport type ActionCreatorWithPayload<\r\n  P,\r\n  T extends string = string\r\n> = WithTypePropertyAndMatch<\r\n  IsUnknownOrNonInferrable<\r\n    P,\r\n    // TS < 3.5 infers non-inferrable types to {}, which does not take `null`. This enforces `undefined` instead.\r\n    <PT extends unknown>(payload: PT) => PayloadAction<PT, T>,\r\n    // default behaviour\r\n    <PT extends P>(payload: PT) => PayloadAction<PT, T>\r\n  >,\r\n  T,\r\n  P\r\n>\r\n\r\n/**\r\n * An action creator that produces actions with a `payload` attribute.\r\n */\r\nexport type PayloadActionCreator<\r\n  P = void,\r\n  T extends string = string,\r\n  PA extends PrepareAction<P> | void = void\r\n> = IfPrepareActionMethodProvided<\r\n  PA,\r\n  ActionCreatorWithPreparedPayload<PA, T>,\r\n  // else\r\n  IfMaybeUndefined<\r\n    P,\r\n    ActionCreatorWithOptionalPayload<P, T>,\r\n    // else\r\n    IfVoid<\r\n      P,\r\n      ActionCreatorWithoutPayload<T>,\r\n      // else\r\n      ActionCreatorWithPayload<P, T>\r\n    >\r\n  >\r\n>\r\n\r\n/**\r\n * A utility function to create an action creator for the given action type\r\n * string. The action creator accepts a single argument, which will be included\r\n * in the action object as a field called payload. The action creator function\r\n * will also have its toString() overriden so that it returns the action type,\r\n * allowing it to be used in reducer logic that is looking for that action type.\r\n *\r\n * @param type The action type to use for created actions.\r\n * @param prepare (optional) a method that takes any number of arguments and returns { payload } or { payload, meta }.\r\n *                If this is given, the resulting action creator will pass it's arguments to this method to calculate payload & meta.\r\n */\r\n\r\nexport function createAction<P = void, T extends string = string>(\r\n  type: T\r\n): PayloadActionCreator<P, T>\r\n\r\nexport function createAction<\r\n  PA extends PrepareAction<any>,\r\n  T extends string = string\r\n>(\r\n  type: T,\r\n  prepareAction: PA\r\n): PayloadActionCreator<ReturnType<PA>['payload'], T, PA>\r\n\r\nexport function createAction(type: string, prepareAction?: Function) {\r\n  function actionCreator(...args: any[]) {\r\n    if (prepareAction) {\r\n      let prepared = prepareAction(...args)\r\n      if (!prepared) {\r\n        throw new Error('prepareAction did not return an object')\r\n      }\r\n\r\n      return {\r\n        type,\r\n        payload: prepared.payload,\r\n        ...('meta' in prepared && { meta: prepared.meta }),\r\n        ...('error' in prepared && { error: prepared.error })\r\n      }\r\n    }\r\n    return { type, payload: args[0] }\r\n  }\r\n\r\n  actionCreator.toString = () => `${type}`\r\n\r\n  actionCreator.type = type\r\n\r\n  actionCreator.match = (action: Action<unknown>): action is PayloadAction =>\r\n    action.type === type\r\n\r\n  return actionCreator\r\n}\r\n\r\n/**\r\n * Returns the action type of the actions created by the passed\r\n * `createAction()`-generated action creator (arbitrary action creators\r\n * are not supported).\r\n *\r\n * @param action The action creator whose action type to get.\r\n * @returns The action type used by the action creator.\r\n */\r\nexport function getType<T extends string>(\r\n  actionCreator: PayloadActionCreator<any, T>\r\n): T {\r\n  return `${actionCreator}` as T\r\n}\r\n\r\n// helper types for more readable typings\r\n\r\ntype Diff<T, U> = T extends U ? never : T\r\n\r\ntype WithPayload<P, T> = T & { payload: P }\r\n\r\ntype WithOptional<M, E, T> = T &\r\n  ([M] extends [never] ? {} : { meta: M }) &\r\n  ([E] extends [never] ? {} : { error: E })\r\n\r\ntype WithTypeProperty<MergeIn, T extends string> = {\r\n  type: T\r\n} & MergeIn\r\n\r\ntype WithMatch<MergeIn, T extends string, P, M = never, E = never> = {\r\n  match(action: Action<unknown>): action is PayloadAction<P, T, M, E>\r\n} & MergeIn\r\n\r\ntype WithTypePropertyAndMatch<\r\n  MergeIn,\r\n  T extends string,\r\n  P,\r\n  M = never,\r\n  E = never\r\n> = WithTypeProperty<WithMatch<MergeIn, T, P, M, E>, T>\r\n\r\ntype IfPrepareActionMethodProvided<\r\n  PA extends PrepareAction<any> | void,\r\n  True,\r\n  False\r\n> = PA extends (...args: any[]) => any ? True : False\r\n\r\ntype MetaOrNever<PA extends PrepareAction<any>> = ReturnType<PA> extends {\r\n  meta: infer M\r\n}\r\n  ? M\r\n  : never\r\n\r\ntype ErrorOrNever<PA extends PrepareAction<any>> = ReturnType<PA> extends {\r\n  error: infer E\r\n}\r\n  ? E\r\n  : never\r\n\r\ntype IfMaybeUndefined<P, True, False> = [undefined] extends [P] ? True : False\r\n\r\ntype IfVoid<P, True, False> = [void] extends [P] ? True : False\r\n","import createNextState, { Draft } from 'immer'\r\nimport { AnyAction, Action, Reducer } from 'redux'\r\n\r\n/**\r\n * Defines a mapping from action types to corresponding action object shapes.\r\n */\r\nexport type Actions<T extends keyof any = string> = Record<T, Action>\r\n\r\n/**\r\n * An *case reducer* is a reducer function for a speficic action type. Case\r\n * reducers can be composed to full reducers using `createReducer()`.\r\n *\r\n * Unlike a normal Redux reducer, a case reducer is never called with an\r\n * `undefined` state to determine the initial state. Instead, the initial\r\n * state is explicitly specified as an argument to `createReducer()`.\r\n *\r\n * In addition, a case reducer can choose to mutate the passed-in `state`\r\n * value directly instead of returning a new state. This does not actually\r\n * cause the store state to be mutated directly; instead, thanks to\r\n * [immer](https://github.com/mweststrate/immer), the mutations are\r\n * translated to copy operations that result in a new state.\r\n */\r\nexport type CaseReducer<S = any, A extends Action = AnyAction> = (\r\n  state: Draft<S>,\r\n  action: A\r\n) => S | void\r\n\r\n/**\r\n * A mapping from action types to case reducers for `createReducer()`.\r\n */\r\nexport type CaseReducers<S, AS extends Actions> = {\r\n  [T in keyof AS]: AS[T] extends Action ? CaseReducer<S, AS[T]> : void\r\n}\r\n\r\n/**\r\n * A utility function that allows defining a reducer as a mapping from action\r\n * type to *case reducer* functions that handle these action types. The\r\n * reducer's initial state is passed as the first argument.\r\n *\r\n * The body of every case reducer is implicitly wrapped with a call to\r\n * `produce()` from the [immer](https://github.com/mweststrate/immer) library.\r\n * This means that rather than returning a new state object, you can also\r\n * mutate the passed-in state object directly; these mutations will then be\r\n * automatically and efficiently translated into copies, giving you both\r\n * convenience and immutability.\r\n *\r\n * @param initialState The initial state to be returned by the reducer.\r\n * @param actionsMap A mapping from action types to action-type-specific\r\n *   case redeucers.\r\n */\r\nexport function createReducer<\r\n  S,\r\n  CR extends CaseReducers<S, any> = CaseReducers<S, any>\r\n>(initialState: S, actionsMap: CR): Reducer<S> {\r\n  return function(state = initialState, action): S {\r\n    // @ts-ignore createNextState() produces an Immutable<Draft<S>> rather\r\n    // than an Immutable<S>, and TypeScript cannot find out how to reconcile\r\n    // these two types.\r\n    return createNextState(state, (draft: Draft<S>) => {\r\n      const caseReducer = actionsMap[action.type]\r\n      return caseReducer ? caseReducer(draft, action) : undefined\r\n    })\r\n  }\r\n}\r\n","import { Reducer } from 'redux'\r\nimport {\r\n  createAction,\r\n  PayloadAction,\r\n  PayloadActionCreator,\r\n  PrepareAction,\r\n  ActionCreatorWithoutPayload,\r\n  ActionCreatorWithPreparedPayload\r\n} from './createAction'\r\nimport { createReducer, CaseReducers, CaseReducer } from './createReducer'\r\n\r\n/**\r\n * An action creator atttached to a slice.\r\n *\r\n * @deprecated please use PayloadActionCreator directly\r\n */\r\nexport type SliceActionCreator<P> = PayloadActionCreator<P>\r\n\r\nexport interface Slice<\r\n  State = any,\r\n  CaseReducers extends SliceCaseReducerDefinitions<State, PayloadActions> = {\r\n    [key: string]: any\r\n  }\r\n> {\r\n  /**\r\n   * The slice name.\r\n   */\r\n  name: string\r\n\r\n  /**\r\n   * The slice's reducer.\r\n   */\r\n  reducer: Reducer<State>\r\n\r\n  /**\r\n   * Action creators for the types of actions that are handled by the slice\r\n   * reducer.\r\n   */\r\n  actions: CaseReducerActions<CaseReducers>\r\n\r\n  caseReducers: SliceDefinedCaseReducers<CaseReducers, State>\r\n}\r\n\r\n/**\r\n * Options for `createSlice()`.\r\n */\r\nexport interface CreateSliceOptions<\r\n  State = any,\r\n  CR extends SliceCaseReducerDefinitions<\r\n    State,\r\n    any\r\n  > = SliceCaseReducerDefinitions<State, any>\r\n> {\r\n  /**\r\n   * The slice's name. Used to namespace the generated action types.\r\n   */\r\n  name: string\r\n\r\n  /**\r\n   * The initial state to be returned by the slice reducer.\r\n   */\r\n  initialState: State\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. For every action type, a matching action creator will be\r\n   * generated using `createAction()`.\r\n   */\r\n  reducers: CR\r\n\r\n  /**\r\n   * A mapping from action types to action-type-specific *case reducer*\r\n   * functions. These reducers should have existing action types used\r\n   * as the keys, and action creators will _not_ be generated.\r\n   */\r\n  extraReducers?: CaseReducers<NoInfer<State>, any>\r\n}\r\n\r\ntype PayloadActions<Types extends keyof any = string> = Record<\r\n  Types,\r\n  PayloadAction\r\n>\r\n\r\ntype CaseReducerWithPrepare<State, Action extends PayloadAction> = {\r\n  reducer: CaseReducer<State, Action>\r\n  prepare: PrepareAction<Action['payload']>\r\n}\r\n\r\ntype SliceCaseReducerDefinitions<State, PA extends PayloadActions> = {\r\n  [ActionType in keyof PA]:\r\n    | CaseReducer<State, PA[ActionType]>\r\n    | CaseReducerWithPrepare<State, PA[ActionType]>\r\n}\r\n\r\ntype IfIsReducerFunctionWithoutAction<R, True, False = never> = R extends (\r\n  state: any\r\n) => any\r\n  ? True\r\n  : False\r\ntype IfIsCaseReducerWithPrepare<R, True, False = never> = R extends {\r\n  prepare: Function\r\n}\r\n  ? True\r\n  : False\r\n\r\ntype PayloadForReducer<R> = R extends (\r\n  state: any,\r\n  action: PayloadAction<infer P>\r\n) => any\r\n  ? P\r\n  : void\r\ntype PrepareActionForReducer<R> = R extends { prepare: infer Prepare }\r\n  ? Prepare\r\n  : never\r\n\r\ntype ActionForReducer<R, S> = R extends (\r\n  state: S,\r\n  action: PayloadAction<infer P>\r\n) => S\r\n  ? PayloadAction<P>\r\n  : R extends {\r\n      reducer(state: any, action: PayloadAction<infer P>): any\r\n    }\r\n  ? PayloadAction<P>\r\n  : unknown\r\n\r\ntype CaseReducerActions<\r\n  CaseReducers extends SliceCaseReducerDefinitions<any, any>\r\n> = {\r\n  [Type in keyof CaseReducers]: IfIsCaseReducerWithPrepare<\r\n    CaseReducers[Type],\r\n    ActionCreatorWithPreparedPayload<\r\n      PrepareActionForReducer<CaseReducers[Type]>\r\n    >,\r\n    // else\r\n    IfIsReducerFunctionWithoutAction<\r\n      CaseReducers[Type],\r\n      ActionCreatorWithoutPayload,\r\n      // else\r\n      PayloadActionCreator<PayloadForReducer<CaseReducers[Type]>>\r\n    >\r\n  >\r\n}\r\n\r\ntype SliceDefinedCaseReducers<\r\n  CaseReducers extends SliceCaseReducerDefinitions<any, any>,\r\n  State = any\r\n> = {\r\n  [Type in keyof CaseReducers]: CaseReducer<\r\n    State,\r\n    ActionForReducer<CaseReducers[Type], State>\r\n  >\r\n}\r\n\r\ntype NoInfer<T> = [T][T extends any ? 0 : never]\r\n\r\ntype SliceCaseReducersCheck<S, ACR> = {\r\n  [P in keyof ACR]: ACR[P] extends {\r\n    reducer(s: S, action?: { payload: infer O }): any\r\n  }\r\n    ? {\r\n        prepare(...a: never[]): { payload: O }\r\n      }\r\n    : {}\r\n}\r\n\r\ntype RestrictCaseReducerDefinitionsToMatchReducerAndPrepare<\r\n  S,\r\n  CR extends SliceCaseReducerDefinitions<S, any>\r\n> = { reducers: SliceCaseReducersCheck<S, NoInfer<CR>> }\r\n\r\nfunction getType(slice: string, actionKey: string): string {\r\n  return `${slice}/${actionKey}`\r\n}\r\n\r\n/**\r\n * A function that accepts an initial state, an object full of reducer\r\n * functions, and a \"slice name\", and automatically generates\r\n * action creators and action types that correspond to the\r\n * reducers and state.\r\n *\r\n * The `reducer` argument is passed to `createReducer()`.\r\n */\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducerDefinitions<State, any>\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers> &\r\n    RestrictCaseReducerDefinitionsToMatchReducerAndPrepare<State, CaseReducers>\r\n): Slice<State, CaseReducers>\r\n\r\n// internal definition is a little less restrictive\r\nexport function createSlice<\r\n  State,\r\n  CaseReducers extends SliceCaseReducerDefinitions<State, any>\r\n>(\r\n  options: CreateSliceOptions<State, CaseReducers>\r\n): Slice<State, CaseReducers> {\r\n  const { name, initialState } = options\r\n  if (!name) {\r\n    throw new Error('`name` is a required option for createSlice')\r\n  }\r\n  const reducers = options.reducers || {}\r\n  const extraReducers = options.extraReducers || {}\r\n  const reducerNames = Object.keys(reducers)\r\n\r\n  const sliceCaseReducersByName: Record<string, CaseReducer> = {}\r\n  const sliceCaseReducersByType: Record<string, CaseReducer> = {}\r\n  const actionCreators: Record<string, PayloadActionCreator> = {}\r\n\r\n  reducerNames.forEach(reducerName => {\r\n    const maybeReducerWithPrepare = reducers[reducerName]\r\n    const type = getType(name, reducerName)\r\n\r\n    let caseReducer: CaseReducer<State, any>\r\n    let prepareCallback: PrepareAction<any> | undefined\r\n\r\n    if (typeof maybeReducerWithPrepare === 'function') {\r\n      caseReducer = maybeReducerWithPrepare\r\n    } else {\r\n      caseReducer = maybeReducerWithPrepare.reducer\r\n      prepareCallback = maybeReducerWithPrepare.prepare\r\n    }\r\n\r\n    sliceCaseReducersByName[reducerName] = caseReducer\r\n    sliceCaseReducersByType[type] = caseReducer\r\n    actionCreators[reducerName] = prepareCallback\r\n      ? createAction(type, prepareCallback)\r\n      : createAction(type)\r\n  })\r\n\r\n  const finalCaseReducers = { ...extraReducers, ...sliceCaseReducersByType }\r\n  const reducer = createReducer(initialState, finalCaseReducers as any)\r\n\r\n  return {\r\n    name,\r\n    reducer,\r\n    actions: actionCreators as any,\r\n    caseReducers: sliceCaseReducersByName as any\r\n  }\r\n}\r\n"],"names":["isPlainObject","value","proto","Object","getPrototypeOf","isPlain","val","Array","isArray","NON_SERIALIZABLE_STATE_MESSAGE","join","NON_SERIALIZABLE_ACTION_MESSAGE","findNonSerializableValue","path","isSerializable","getEntries","foundNestedSerializable","keyPath","entries","property","nestedValue","nestedPath","concat","createSerializableStateInvariantMiddleware","options","ignoredActions","storeAPI","next","action","length","indexOf","type","foundActionNonSerializableValue","console","error","result","state","getState","foundStateNonSerializableValue","isBoolean","x","getDefaultMiddleware","thunk","immutableCheck","serializableCheck","middlewareArray","push","thunkMiddleware","withExtraArgument","extraArgument","createImmutableStateInvariantMiddleware","require","immutableOptions","unshift","serializableOptions","IS_PRODUCTION","process","configureStore","reducer","undefined","middleware","devTools","preloadedState","enhancers","rootReducer","combineReducers","Error","middlewareEnhancer","applyMiddleware","finalCompose","compose","composeWithDevTools","trace","storeEnhancers","composedEnhancer","createStore","createAction","prepareAction","actionCreator","prepared","payload","meta","toString","match","getType","createReducer","initialState","actionsMap","createNextState","draft","caseReducer","slice","actionKey","createSlice","name","reducers","extraReducers","reducerNames","keys","sliceCaseReducersByName","sliceCaseReducersByType","actionCreators","forEach","reducerName","maybeReducerWithPrepare","prepareCallback","prepare","finalCaseReducers","actions","caseReducers"],"mappings":"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"}